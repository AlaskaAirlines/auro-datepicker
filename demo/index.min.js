import { html, css, LitElement } from 'lit';
import { html as html$1 } from 'lit/static-html.js';
import AuroFormValidation from '@aurodesignsystem/auro-formvalidation/src/validation.js';
import { AuroDependencyVersioning } from '@aurodesignsystem/auro-library/scripts/runtime/dependencyTagVersioning.mjs';
import AuroLibraryRuntimeUtils from '@aurodesignsystem/auro-library/scripts/utils/runtimeUtils.mjs';
import { __decorate } from 'tslib';
import { property } from 'lit/decorators.js';
import '@material/mwc-icon-button';
import '@material/mwc-menu';
import '@material/mwc-list/mwc-list-item';
import { getTime, startOfDay, format, parse, endOfMonth, getDay, addDays, addMonths, addYears, subMonths, subYears, getMonth, getYear } from 'date-fns';
import { enUS } from 'date-fns/esm/locale';
import { classMap } from 'lit/directives/class-map.js';
import { AuroPopover } from '@aurodesignsystem/auro-popover/src/auro-popover.js';
import chevronLeft from '@alaskaairux/icons/dist/icons/interface/chevron-left.mjs';
import chevronRight from '@alaskaairux/icons/dist/icons/interface/chevron-right.mjs';
import { AuroDropdown } from '@aurodesignsystem/auro-dropdown/src/auro-dropdown.js';
import { AuroInput } from '@aurodesignsystem/auro-input/src/auro-input.js';

class AuroDatepickerUtilities {

  /**
   * Returns true if value passed in is a valid date.
   * @private
   * @param {String} date - Date to validate.
   * @returns {Boolean}
   */
  validDateStr(date) {
    const dateStrLength = 10;

    if (date.length === dateStrLength && Date.parse(date)) {
      return true;
    }

    return false;
  }

  /**
   * Converts any date object to a date object representing the first day of the month.
   * @param {Object} date - Date to convert to the first day of the month.
   * @returns {Object} Returns the auro-calendar-months HTML.
   */
  convertDateToFirstOfMonth(date) {
    const dateObj = new Date(date);

    return new Date(dateObj.getFullYear(), dateObj.getMonth(), 1);
  }

  /**
   * Calculate the number of months between two dates.
   * @param {Object} date1 - First date to compare.
   * @param {Object} date2 - Second date to compare.
   * @returns {Number} Returns the number of months between the two dates.
   */
  monthDiff(date1, date2) {
    let months = 0;
    months = (date2.getFullYear() - date1.getFullYear()) * 12; // eslint-disable-line no-magic-numbers
    months -= date1.getMonth();
    months += date2.getMonth();
    months += 1;

    return months <= 0 ? 0 : months;
  }

  /**
   * Convert a date object to string format.
   * @private
   * @param {Object} date - Date to convert to string.
   * @returns {Object} Returns the date as a string.
   */
  getDateAsString(date) {
    const year = new Date(date).getFullYear();
    const month = new Date(date).getMonth() + 1;
    const day = new Date(date).getDate();

    const dateStr = `${month}/${day}/${year}`;

    return dateStr;
  }

  /**
   * Function to generate checkmark svg.
   * @private
   * @param {Object} icon - Icon object containing the SVG.
   * @returns {Object} Returns the svg portion of the icon object.
   */
  generateIconHtml(icon) {
    this.dom = new DOMParser().parseFromString(icon.svg, 'text/html');
    this.svg = this.dom.body.firstChild;

    return this.svg;
  }

  /**
   * Compares two dates to see if they match.
   * @private
   * @param {Object} date1 - First date to compare.
   * @param {Object} date2 - Second date to compare.
   * @returns {Boolean} Returns true if the dates match.
   */
  datesMatch(date1, date2) {
    const match = new Date(date1).getTime() === new Date(date2).getTime();

    return match;
  }
}

class UtilitiesCalendarRender {
  constructor() {
    this.util = new AuroDatepickerUtilities();
  }

  /**
   * Attempt to update the central date but only if the date is a valid date.
   * @param {Object} elem - The element to set the centralDate on.
   * @param {String} date - The date to set the centralDate to.
   * @private
   */
  updateCentralDate(elem, date) {
    const dateObj = new Date(date);

    if (!isNaN(dateObj)) {
      elem.centralDate = dateObj;
    }
  }

  /**
   * Determine how many months to render based on the defined calendar range.
   * @param {Object} elem - The auro-calendar element.
   * @private
   * @returns {Number} Returns the number of months between the calendarStartDate and the calendarEndDate.
   */
  determineDefinedCalendarRange(elem) {
    if (elem.getAttribute('calendarStartDate') && elem.getAttribute('calendarEndDate')) {
      // if we have a defined range of months, use that
      elem.calendarRangeMonths = elem.util.monthDiff(new Date(elem.getAttribute('calendarStartDate')), new Date(elem.getAttribute('calendarEndDate')));
    } else {
      // if we don't have a defined range of months, use undefined
      elem.calendarRangeMonths = undefined;
    }

    return elem.calendarRangeMonths;
  }

  /**
   * Determines how many calendar months can be rendered based on the screen size and defined range.
   * @param {Object} elem - The auro-calendar element.
   * @private
   * @returns {Number} Returns the maximum number of months that can be rendered.
   */
  maximumRenderableMonths(elem) {
    const definedRangeMonths = this.determineDefinedCalendarRange(elem);

    // number of calendars that could be rendered at a time
    let numCalendars = 1;

    // range supported calendars use two viewable months in desktop view
    if (!elem.noRange) {
      numCalendars = 2; // eslint-disable-line no-magic-numbers
    }

    // change the max calendar number when viewed on mobile
    if (window.innerWidth < elem.mobileBreakpoint) {
      // use definedRangeMonths if we have it otherwise default to 12
      numCalendars = definedRangeMonths || 12; // eslint-disable-line no-magic-numbers
    }

    // If we have a defined range of months and it's less than the numCalendars, use the defined range.
    // This covers the scenario where the datepicker has "range" but the available months are less than 2.
    if (definedRangeMonths && definedRangeMonths < numCalendars) {
      numCalendars = definedRangeMonths;
    }

    return numCalendars;
  }


  /**
   * Determines the number of months rendered inside the calendar.
   * @param {Object} elem - The auro-calendar element.
   * @private
   * @returns {void}
   */
  determineNumCalendarsToRender(elem) {
    // 1. Determine the maximum number of months that can be rendered.
    //    This is based on the screen size and the defined range of months.
    const maxRenderableMonths = this.maximumRenderableMonths(elem);

    // 2. Start by assuming we can render the max number of months.
    let calendarCount = maxRenderableMonths;

    // 3. If we didn't get a count early, restrict based on min/max date.
    if (!calendarCount && elem.minDate && elem.maxDate) {
      const monthsInRange = this.util.monthDiff(new Date(elem.minDate), new Date(elem.maxDate));

      if (monthsInRange < maxRenderableMonths) {
        calendarCount = monthsInRange;
      }
    }

    if (elem.numCalendars !== calendarCount) {
      elem.numCalendars = calendarCount;
      elem.requestUpdate();
    }
  }

  /**
   * Determine which month is to be rendered first.
   * @param {Object} elem - The auro-calendar element.
   * @private
   * @returns {void}
   */
  setFirstRenderableMonthDate(elem) {
    const start = elem.getAttribute('calendarStartDate');
    const min = elem.getAttribute('minDate');

    let firstMonthDate = new Date();

    if (start) {
      firstMonthDate = new Date(start);
    } else if (min) {
      firstMonthDate = new Date(min);
    }

    // sets to the first day of the month
    elem.firstMonthRenderable = elem.util.convertDateToFirstOfMonth(firstMonthDate);
  }

  /**
   * Renders one auro-calendar-month HTML for the given month/date combination.
   * @private
   * @param {Object} elem - The auro-calendar element.
   * @param {Number} month - Month the calendar displays.
   * @param {Number} year - Year the calendar displays.
   * @returns {Object} Returns the auro-calendar-month HTML.
   */
  renderCalendar(elem, month, year) {
    return html`
      <auro-calendar-month
        id="${`month-${month}-${year}`}"
        .disabledDays="${elem.disabledDays}"
        .min="${elem.min}"
        .max="${elem.max}"
        ?noRange="${elem.noRange}"
        .hoveredDate="${elem.hoveredDate}"
        .dateTo="${elem.dateTo}"
        .dateFrom="${elem.dateFrom}"
        .locale="${elem.locale}"
        month="${month}"
        year="${year}"
        @hovered-date-changed="${elem.hoveredDateChanged}"
        @date-from-changed="${elem.dateFromChanged}"
        @date-to-changed="${elem.dateToChanged}"
      >
      </auro-calendar-month>
    `;
  }
}

var styleCss$3 = css`.util_displayInline{display:inline}.util_displayInlineBlock{display:inline-block}.util_displayBlock{display:block}.util_displayFlex{display:flex}.util_displayHidden{display:none}.util_displayHiddenVisually{position:absolute;overflow:hidden;clip:rect(1px, 1px, 1px, 1px);width:1px;height:1px;padding:0;border:0}[auro-input]::part(iconContainer){top:0;display:flex;height:100%;align-items:center}[auro-input]::part(accentIcon){transition:all .3s cubic-bezier(0.215, 0.61, 0.355, 1)}[auro-input]::part(helpText){display:none}[auro-input]::part(wrapper){border-width:0 !important}.outerWrapper{position:relative}.datepickerElement-helpText{margin:var(--ds-size-50, 0.25rem) 0;font-size:var(--ds-text-body-size-xs, 0.75rem);line-height:1rem}.dpTriggerContent{display:flex;flex-direction:row}.dpTriggerContent [auro-input]{flex:1}.dpTriggerContent [auro-input]:first-of-type{margin-right:var(--ds-size-150, 0.75rem)}.dpTriggerContent [auro-input]:nth-child(2){margin-left:var(--ds-size-150, 0.75rem)}.dpTriggerContent [auro-input]:nth-child(2)::part(accentIcon){display:none}.dpTriggerContent [auro-input]:nth-child(2)::part(label){left:0;width:100%}.dpTriggerContent [auro-input]:nth-child(2)::part(input){padding-left:0}.dpTriggerContent [auro-input]:nth-child(2):before{position:absolute;top:13px;left:calc(var(--ds-size-150, 0.75rem)*-1);display:block;width:1px;height:2rem;content:""}:host([range]) [auro-input]{max-width:50%}@media screen and (max-width: 576px){::part(popover){position:fixed !important;top:0 !important;left:0 !important;width:100vw !important;height:100vh !important;margin-bottom:var(--ds-size-200, 1rem);transform:unset !important}.calendarWrapper{display:flex;height:100%;flex-direction:row;justify-content:center}}`;

var colorCss$3 = css`.util_displayInline{display:inline}.util_displayInlineBlock{display:inline-block}.util_displayBlock{display:block}.util_displayFlex{display:flex}.util_displayHidden{display:none}.util_displayHiddenVisually{position:absolute;overflow:hidden;clip:rect(1px, 1px, 1px, 1px);width:1px;height:1px;padding:0;border:0}[auro-input]::part(wrapper){--ds-auro-input-border-color: transparent;--ds-auro-input-container-color: transparent}.dpTriggerContent [auro-input]:nth-child(2):before{background-color:var(--ds-auro-datepicker-range-input-divider-color)}.placeholderDate{color:var(--ds-auro-datepicker-placeholder-color)}`;

var tokensCss = css`:host{--ds-auro-datepicker-placeholder-color: var(--ds-color-text-secondary-default, #525252);--ds-auro-datepicker-range-input-divider-color: var(--ds-color-border-primary-default, #585e67);--ds-auro-calendar-mobile-footer-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-calendar-mobile-header-boxshadow-color: var(--ds-elevation-200, 0px 0px 10px rgba(0, 0, 0, 0.15));--ds-auro-calendar-mobile-header-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-calendar-mobile-header-divider-color: var(--ds-color-border-divider-default, rgba(0, 0, 0, 0.12));--ds-auro-calendar-mobile-header-text-color: var(--ds-color-text-secondary-default, #525252);--ds-auro-calendar-nav-btn-border-color: transparent;--ds-auro-calendar-nav-btn-chevron-color: var(--ds-color-icon-ui-primary-default-default, #2c67b5);--ds-auro-calendar-nav-btn-container-color: transparent;--ds-auro-calendar-month-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-calendar-month-divider-color: var(--ds-color-border-divider-default, rgba(0, 0, 0, 0.12));--ds-auro-calendar-month-header-color: var(--ds-color-text-primary-default, #2a2a2a);--ds-auro-calendar-cell-border-color: transparent;--ds-auro-calendar-cell-boxshadow-color: var(--ds-elevation-200, 0px 0px 10px rgba(0, 0, 0, 0.15));--ds-auro-calendar-cell-container-color: transparent;--ds-auro-calendar-cell-in-range-color: var(--ds-color-container-secondary-default, #f7f7f7);--ds-auro-calendar-cell-price-text-color: var(--ds-color-text-primary-default, #2a2a2a);--ds-auro-calendar-cell-text-color: var(--ds-color-text-primary-default, #2a2a2a)}`;

var styleCss$2 = css`:host{--calendar-width: 336px;--mobile-footer-height: 150px;--mobile-header-height: 68px;height:100vh;height:100dvh}@media screen and (max-width: 576px){:host{width:100%}}.calendarNavBtn{display:flex;width:var(--ds-size-500, 2.5rem);height:var(--ds-size-500, 2.5rem);align-items:center;justify-content:center;border-width:1px;border-style:solid;border-radius:50%;cursor:pointer}.prevMonth,.nextMonth{position:absolute;top:var(--ds-size-200, 1rem)}.prevMonth{left:var(--ds-size-50, 0.25rem)}.nextMonth{right:var(--ds-size-50, 0.25rem)}.headerActions{padding:0 var(--ds-size-200, 1rem)}.mobileHeader{display:none;width:100%;height:var(--mobile-header-height);z-index:1;align-items:center;flex-direction:row}.headerDateFrom{display:flex;height:var(--mobile-header-height);flex:1;flex-direction:column;justify-content:center;padding:0 var(--ds-size-150, 0.75rem) 0 var(--ds-size-200, 1rem)}.mobileDateLabel{font-size:var(--ds-text-body-size-xs, 0.75rem)}.headerDateTo{height:calc(var(--mobile-header-height) - var(--ds-size-300, 1.5rem));padding:var(--ds-size-300, 1.5rem) var(--ds-size-100, 0.5rem) 0 var(--ds-size-200, 1rem)}:host(:not([noRange])) .headerDateTo{position:relative;display:flex;flex:1;flex-direction:column;justify-content:center}:host(:not([noRange])) .headerDateTo:after{position:absolute;top:calc(50% + 10px);left:0;display:block;width:1px;height:var(--ds-size-300, 1.5rem);content:"";transform:translateY(-50%)}.mobileFooter{display:none;width:100%;align-items:flex-end;flex-direction:column;justify-content:flex-end}.mobileFooterActions{position:relative;bottom:0;left:50%;display:none;width:calc(100% - var(--ds-size-200, 1rem)*2);align-items:flex-end;flex-direction:column;justify-content:flex-end;padding:var(--ds-size-150) calc(var(--ds-size-200, 1rem));transform:translateX(-50%)}.mobileFooterActions auro-button{width:100%}@media screen and (max-width: 576px){.prevMonth,.nextMonth{display:none}.mobileHeader,.mobileFooter,.mobileFooterActions{display:flex}.calendarWrapper{display:flex;height:100%;flex-direction:column;overflow:auto hidden}.calendars{display:flex;flex-direction:column;flex:1;align-items:center;width:100%;overflow-y:scroll;overscroll-behavior:contain}.calendars:after{display:block;width:100%;height:var(--mobile-footer-height);content:""}}@media screen and (min-width: 576px){.calendars{display:flex;flex-direction:row}}`;

var colorCss$2 = css`.calendarNavBtn{border-color:var(--ds-auro-calendar-nav-btn-border-color);background-color:var(--ds-auro-calendar-nav-btn-container-color);color:var(--ds-auro-calendar-nav-btn-chevron-color)}.calendarNavBtn:hover,.calendarNavBtn:focus{--ds-auro-calendar-nav-btn-border-color: var(--ds-color-border-ui-default-default, #2c67b5)}.calendarNavBtn:active{--ds-auro-calendar-nav-btn-border-color: var(--ds-color-border-ui-default-default, #2c67b5);box-shadow:inset 0 0 0 1px var(--ds-auro-calendar-nav-btn-border-color)}.mobileHeader{background-color:var(--ds-auro-calendar-mobile-header-container-color);box-shadow:0 0 10px var(--ds-auro-calendar-mobile-header-boxshadow-color)}.mobileDateLabel{color:var(--ds-auro-calendar-mobile-header-text-color)}:host(:not([noRange])) .headerDateTo:after{background-color:var(--ds-auro-calendar-mobile-header-divider-color)}.mobileFooterActions{background-color:var(--ds-auro-calendar-mobile-footer-container-color)}@media screen and (max-width: 576px){.calendarNavBtn{--ds-auro-calendar-nav-btn-border-color: var(--ds-color-border-ui-default-default, #2c67b5)}}`;

var styleCss$1 = css`*,*:before,*:after{box-sizing:border-box}@media(prefers-reduced-motion: reduce){*,*:before,*:after{animation-duration:.01ms !important;animation-iteration-count:1 !important;transition-duration:.01ms !important}}*:focus-visible{outline:0}*:focus-visible{outline:0}:focus:not(:focus-visible){outline:3px solid transparent}:host{position:relative;display:block;width:calc(100% - var(--ds-size-200, 1rem) - var(--ds-size-200, 1rem));margin:0 var(--ds-size-200, 1rem)}@media screen and (min-width: 576px){:host{width:336px;padding:var(--ds-size-200, 1rem)}}@media screen and (min-width: 576px){:host(:not(:last-of-type)):after{position:absolute;top:var(--ds-size-200, 1rem);right:calc(-1*var(--ds-size-200, 1rem));height:calc(100% - var(--ds-size-200, 1rem) - var(--ds-size-200, 1rem));display:block;width:1px;content:""}}.header{display:flex;align-items:center;flex-direction:row;padding:calc(var(--ds-size-100, 0.5rem) + var(--ds-size-50, 0.25rem) + var(--ds-size-25, 0.125rem)) 0 calc(var(--ds-size-100, 0.5rem) + var(--ds-size-50, 0.25rem) + var(--ds-size-25, 0.125rem));text-align:center}.headerTitle{display:flex;align-items:center;flex:1;flex-direction:row;justify-content:center;font-size:var(--ds-text-heading-400-size, 1.25rem);font-weight:var(--ds-text-heading-400-weight, 300);line-height:var(--ds-text-heading-400-height, 1.625rem)}.headerTitle div:first-child{margin-right:var(--ds-size-100, 0.5rem)}.calendarNavBtn{position:relative;display:flex;width:var(--ds-size-500, 2.5rem);height:var(--ds-size-500, 2.5rem);align-items:center;justify-content:center;border-width:1px;border-style:solid;border-radius:50%;cursor:pointer}.table{width:100%;border-collapse:collapse}.thead{margin-bottom:var(--ds-size-100, 0.5rem)}.th{display:flex;flex:1;align-items:center;justify-content:center;font-weight:700}.tbody{width:100%;transition:all 0ms;transform:translateX(0)}@media screen and (min-width: 576px){.tbody{height:384px}}.td{flex:1;margin:0;padding:0}.tr{display:flex;flex-direction:row;width:100%}`;

var colorCss$1 = css`*,*:before,*:after{box-sizing:border-box}@media(prefers-reduced-motion: reduce){*,*:before,*:after{animation-duration:.01ms !important;animation-iteration-count:1 !important;transition-duration:.01ms !important}}*:focus-visible{outline:0}*:focus-visible{outline:0}:focus:not(:focus-visible){outline:3px solid transparent}:host{background-color:var(--ds-auro-calendar-month-container-color)}@media screen and (min-width: 576px){:host(:not(:last-of-type)):after{background-color:var(--ds-auro-calendar-month-divider-color)}}.header{color:var(--ds-auro-calendar-month-header-color)}`;

class RangeDatepickerCell extends LitElement {
    constructor() {
        super(...arguments);
        this.day = null;
        this.selected = false;
        this.hovered = false;
        this.dateTo = null;
        this.dateFrom = null;
        this.month = null;
        this.min = null;
        this.max = null;
        this.disabled = false;
        this.disabledDays = [];
        this.hoveredDate = null;
        this.isCurrentDate = false;
        this._locale = null;

    }
    get locale() {
        return this._locale ? this._locale : enUS;
    }
    set locale(value) {
        const oldValue = this._locale;
        this._locale = value;
        this.requestUpdate('locale', oldValue);
    }
    render() {
        var _a, _b;
        return html `
      <button
        @click="${this.handleTap}"
        @mouseover="${this.handleHover}"
        @focus="${this.handleHover}"
        class="day ${this.isCurrentDate ? 'currentDate' : ''} ${this.isSelected(this.selected)} ${this.isHovered(this.hovered)} ${this.isEnabled(this.day, this.min, this.max, this.disabledDays)}"
        ?disabled="${this.disabled}"
        title="${this.getTitle((_a = this.day) === null || _a === void 0 ? void 0 : _a.date)}"
      >
        <div class="currentDayMarker">${(_b = this.day) === null || _b === void 0 ? void 0 : _b.title}</div>
      </button>
    `;
    }
    updated(properties) {
        if (properties.has('dateFrom') ||
            properties.has('dateTo') ||
            properties.has('hoveredDate') ||
            properties.has('day')) {
            this.dateChanged(this.dateFrom, this.dateTo, this.hoveredDate, this.day);
        }
    }
    dateChanged(dateFrom, dateTo, hoveredDate, day) {
        this.selected = false;
        this.hovered = false;
        const parsedDateFrom = parseInt(dateFrom, 10);
        const parsedDateTo = parseInt(dateTo, 10);
        if (day) {
            if (getTime(startOfDay(parsedDateTo * 1000)) / 1000 === day.date ||
                getTime(startOfDay(parsedDateFrom * 1000)) / 1000 === day.date) {
                this.selected = true;
            }
            if (((hoveredDate === day.date || day.date < hoveredDate) &&
                day.date > parsedDateFrom &&
                !parsedDateTo &&
                !Number.isNaN(parsedDateFrom) &&
                parsedDateFrom !== undefined &&
                !this.selected) ||
                (day.date > parsedDateFrom && day.date < parsedDateTo)) {
                this.hovered = true;
            }
        }
    }
    handleTap() {
        var _a;
        if (!this.disabled) {
            this.dispatchEvent(new CustomEvent('date-is-selected', {
                detail: { date: (_a = this.day) === null || _a === void 0 ? void 0 : _a.date },
            }));
        }
    }
    handleHover() {
        var _a;
        this.dispatchEvent(new CustomEvent('date-is-hovered', {
            detail: { date: (_a = this.day) === null || _a === void 0 ? void 0 : _a.date },
        }));
    }
    isSelected(selected) {
        return selected ? 'selected' : '';
    }
    isHovered(hovered) {
        return hovered ? 'hovered' : '';
    }
    isEnabled(day, min, max, disabledDays) {
        this.disabled = false;
        if (disabledDays && day && day.date) {
            if (day.date < min ||
                day.date > max ||
                disabledDays.findIndex(disabledDay => parseInt(disabledDay, 10) === day.date) !== -1) {
                this.disabled = true;
                return 'disabled';
            }
        }
        return '';
    }
    getTitle(date) {
        if (date === undefined) {
            return '';
        }
        return format(date * 1000, 'PPPP', {
            locale: this.locale,
        });
    }
}
RangeDatepickerCell.styles = css `
    :host {
      display: block;
    }

    .day {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 38px;
      width: 38px;
      margin: 0;
      padding: 0;
      color: var(--wc-datepicker-cell-text);

      border: none;
      outline: none;
      background-color: transparent;
    }

    .day:focus {
      outline: 1px solid
        var(--wc-datepicker-cell-hovered, rgba(0, 150, 136, 0.5));
    }

    .day:not(.disabled):hover {
      background: var(--wc-datepicker-cell-hover, #e4e7e7);
      cursor: pointer;
    }

    .day.hovered {
      background: var(
        --wc-datepicker-cell-hovered,
        rgba(0, 150, 136, 0.5)
      ) !important;
      color: var(--wc-datepicker-cell-hovered-text, white);
    }

    .day.selected {
      background: var(
        --wc-datepicker-cell-selected,
        rgb(0, 150, 136)
      ) !important;
      color: var(--wc-datepicker-cell-selected-text, white);
    }

    .day.currentDate .currentDayMarker {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      text-align: center;

      width: 80%;
      height: 80%;
      font-weight: var(--wc-current-day-font-weight, bold);
      border-radius: 50%;
      background-color: var(--wc-current-day-color);
      color: var(--wc-current-day-color-text);
    }

    .day.disabled {
      opacity: 0.4;
    }
  `;
__decorate([
    property({ type: Object })
], RangeDatepickerCell.prototype, "day", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCell.prototype, "selected", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCell.prototype, "hovered", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCell.prototype, "dateTo", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCell.prototype, "dateFrom", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCell.prototype, "month", void 0);
__decorate([
    property({ type: Number })
], RangeDatepickerCell.prototype, "min", void 0);
__decorate([
    property({ type: Number })
], RangeDatepickerCell.prototype, "max", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCell.prototype, "disabled", void 0);
__decorate([
    property({ type: Array })
], RangeDatepickerCell.prototype, "disabledDays", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCell.prototype, "hoveredDate", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCell.prototype, "isCurrentDate", void 0);
__decorate([
    property({ type: Object })
], RangeDatepickerCell.prototype, "locale", null);
AuroLibraryRuntimeUtils.prototype.registerComponent('wc-range-datepicker-cell', RangeDatepickerCell);

class Day {
    constructor(date) {
        this.date = parseInt(format(date, 't'), 10);
        this.title = parseInt(format(date, 'd'), 10);
    }
}

class RangeDatepickerCalendar extends LitElement {
    constructor() {
        super();
        /**
         * Date from. Format is Unix timestamp.
         */
        this.dateFrom = null;
        /**
         * Date to. Format is Unix timestamp.
         */
        this.dateTo = null;
        this.hoveredDate = null;
        this.enableYearChange = false;
        this.month = '01';
        this.narrow = false;
        this.noRange = false;
        this.next = false;
        this.prev = false;
        this.year = 2020;
        this.disabledDays = [];
        /**
         * Max date. Format is Unix timestamp
         */
        this.max = null;
        /**
         * Minimal date. Format is Unix timestamp
         */
        this.min = null;
        this.yearsList = [];
        this.monthsList = [];
        this.dayNamesOfTheWeek = [];
        this.daysOfMonth = [];
        this._locale = null;
        this.currentDate = parseInt(format(startOfDay(Date.now()), 't'), 10);
        this.localeChanged();
        this.yearAndMonthChanged(this.year, this.month);
    }
    get locale() {
        return this._locale ? this._locale : enUS;
    }
    set locale(value) {
        const oldValue = this._locale;
        this._locale = value;
        this.requestUpdate('locale', oldValue);
    }
    render() {
        var _a, _b;
        return html `
      <div>
        <div class="header">
          ${this.renderPrevButton()}
          <div class="headerTitle">
            <div>${this.computeCurrentMonthName(this.month, this.year)}</div>
            <div>${this.renderYear()}</div>
          </div>
          ${this.renderNextButton()}
        </div>

        <div class="table">
          <div class="thead">
            <div class="tr">
              ${(_a = this.dayNamesOfTheWeek) === null || _a === void 0 ? void 0 : _a.map(dayNameOfWeek => this.renderDayOfWeek(dayNameOfWeek))}
            </div>
          </div>
          <div class="tbody">
            ${(_b = this.daysOfMonth) === null || _b === void 0 ? void 0 : _b.map(week => this.renderWeek(week))}
          </div>
        </div>
      </div>
    `;
    }
    renderPrevButton() {
        if (this.prev || this.narrow || this.enableYearChange) {
            return html `<mwc-icon-button
        icon="chevron_left"
        @click="${this.handlePrevMonth}"
      ></mwc-icon-button>`;
        }
        return null;
    }
    renderNextButton() {
        if (this.next || this.narrow || this.enableYearChange) {
            return html `<mwc-icon-button
        icon="chevron_right"
        @click="${this.handleNextMonth}"
      ></mwc-icon-button>`;
        }
        return null;
    }
    renderYear() {
        if (this.enableYearChange) {
            return html `
        <div class="year-container">
          ${this.year}
          <mwc-icon-button
            icon="arrow_drop_down"
            @click="${this.handleOpenYearSelection}"
          ></mwc-icon-button>
          <mwc-menu class="year-change" @selected="${this.handleYearSelected}">
            ${this.yearsList.map(i => this.renderYearItem(i))}
          </mwc-menu>
        </div>
      `;
        }
        return html `${this.year}`;
    }
    renderYearItem(item) {
        return html ` <mwc-list-item value="${item}">${item}</mwc-list-item> `;
    }
    renderDayOfWeek(dayOfWeek) {
        return html `<div class="th">${dayOfWeek}</div>`;
    }
    renderWeek(week) {
        return html `
      <div class="tr">${week.map(day => this.renderDay(day))}</div>
    `;
    }
    renderDay(day) {
        return html `
      <div class="td ${this.tdIsEnabled(day)}">
        ${day
            ? html `
              <wc-range-datepicker-cell
                .disabledDays="${this.disabledDays}"
                .min="${this.min}"
                .max="${this.max}"
                .month="${this.month}"
                .hoveredDate="${this.hoveredDate}"
                .dateTo="${this.dateTo}"
                .dateFrom="${this.dateFrom}"
                .locale="${this.locale}"
                .day="${day}"
                ?isCurrentDate="${this.isCurrentDate(day)}"
                @date-is-selected="${this.handleDateSelected}"
                @date-is-hovered="${this.handleDateHovered}"
              >
              </wc-range-datepicker-cell>
            `
            : null}
      </div>
    `;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async firstUpdated() {
        this.monthsList = [
            '01',
            '02',
            '03',
            '04',
            '05',
            '06',
            '07',
            '08',
            '09',
            '10',
            '11',
            '12',
        ];
        setTimeout(() => {
            this.setYears(1930, 2100);
        });
        await this.updateComplete;
    }
    updated(properties) {
        if (properties.has('locale')) {
            this.localeChanged();
        }
        if (properties.has('year')) {
            this.dispatchEvent(new CustomEvent('year-changed', { detail: { value: this.year } }));
        }
        if (properties.has('year') || properties.has('month')) {
            this.yearAndMonthChanged(this.year, this.month);
        }
    }
    isCurrentDate(day) {
        const dayDate = day.date;
        return dayDate === this.currentDate;
    }
    localeChanged() {
        const dayNamesOfTheWeek = [];
        for (let i = 0; i < 7; i += 1) {
            dayNamesOfTheWeek.push(this.locale.localize.day(i, { width: 'short' }));
        }
        const firstDayOfWeek = this.locale.options.weekStartsOn
            ? this.locale.options.weekStartsOn
            : 0;
        const tmp = dayNamesOfTheWeek.slice().splice(0, firstDayOfWeek);
        const newDayNamesOfTheWeek = dayNamesOfTheWeek
            .slice()
            .splice(firstDayOfWeek, dayNamesOfTheWeek.length)
            .concat(tmp);
        this.dayNamesOfTheWeek = newDayNamesOfTheWeek;
    }
    yearAndMonthChanged(year, month) {
        if (year && month) {
            let monthMinus = `${month}`;
            monthMinus = monthMinus.substring(monthMinus.length - 2);
            let startDateString = `01/${monthMinus}/${year}`;
            let startDateFn = parse(startDateString, 'dd/MM/yyyy', new Date());
            const endDateFn = endOfMonth(startDateFn);
            const endDateString = format(endDateFn, 'dd/MM/yyyy');
            const firstDayOfWeek = this.locale.options.weekStartsOn
                ? this.locale.options.weekStartsOn
                : 0;
            const rows = [];
            let columns = [];
            const lastDayOfWeek = 6;
            while (startDateString !== endDateString) {
                let dayNumberFn = getDay(startDateFn) - firstDayOfWeek;
                if (dayNumberFn < 0) {
                    dayNumberFn = 6;
                }
                const columnFn = new Day(startDateFn);
                columns.push(columnFn);
                if (dayNumberFn === lastDayOfWeek) {
                    for (let i = columns.length; i < lastDayOfWeek + 1; i += 1) {
                        columns.unshift(null);
                    }
                    rows.push(columns.slice());
                    columns = [];
                }
                startDateFn = addDays(startDateFn, 1);
                startDateString = format(startDateFn, 'dd/MM/yyyy');
                if (startDateString === endDateString) {
                    const endColumnFn = new Day(startDateFn);
                    columns.push(endColumnFn);
                    for (let i = columns.length; i <= lastDayOfWeek; i += 1) {
                        columns.push(null);
                    }
                    rows.push(columns.slice());
                    columns = [];
                }
            }
            this.daysOfMonth = rows;
        }
    }
    computeCurrentMonthName(month, year) {
        return format(new Date(year, parseInt(month, 10) - 1), 'MMMM', {
            locale: this.locale,
        });
    }
    tdIsEnabled(day) {
        return day ? 'enabled' : '';
    }
    handleDateSelected(e) {
        const { detail } = e;
        const { date } = detail;
        if (!this.noRange) {
            if (this.dateFrom && this.dateTo) {
                this.dateFrom = date;
                this.dateTo = null;
                this.hoveredDate = null;
            }
            else if (!this.dateFrom || (this.dateFrom && date < this.dateFrom)) {
                this.dateFrom = date;
            }
            else if (!this.dateTo || (this.dateTo && date > this.dateTo)) {
                this.dateTo = date;
            }
        }
        else {
            this.dateFrom = date;
        }
        this.dispatchEvent(new CustomEvent('date-from-changed', { detail: { value: this.dateFrom } }));
        this.dispatchEvent(new CustomEvent('date-to-changed', { detail: { value: this.dateTo } }));
    }
    handleOpenYearSelection() {
        var _a;
        const menu = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.year-change');
        const index = menu.items.findIndex((item) => item.value === this.year.toString());
        menu.select(index);
        menu.show();
    }
    handleYearSelected() {
        var _a;
        const menu = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.year-change');
        const selected = menu.selected;
        this.year = parseInt(selected === null || selected === void 0 ? void 0 : selected.value, 10);
    }
    handleDateHovered(e) {
        this.hoveredDate = e.detail.date;
        this.dispatchEvent(new CustomEvent('hovered-date-changed', {
            detail: { value: this.hoveredDate },
        }));
    }
    handleNextMonth() {
        var _a, _b;
        const tbody = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.tbody');
        const monthName = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('.header > div');
        tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('withTransition');
        tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('moveToLeft');
        monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('withTransition');
        monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('moveToLeft');
        const month = parse(this.month, 'MM', new Date());
        const monthPlusDate = addMonths(month, 1);
        const monthPlusString = format(monthPlusDate, 'MM', {
            locale: this.locale,
        });
        this.month = monthPlusString;
        if (this.month === '01') {
            const year = parse(this.year.toString(), 'yyyy', new Date());
            const yearPlusDate = addYears(year, 1);
            const yearPlusString = format(yearPlusDate, 'yyyy', {
                locale: this.locale,
            });
            this.year = parseInt(yearPlusString, 10);
        }
        this.dispatchEvent(new CustomEvent('next-month'));
        setTimeout(() => {
            tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('withTransition');
            tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('moveToRight');
            tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('moveToLeft');
            monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('withTransition');
            monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('moveToRight');
            monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('moveToLeft');
            setTimeout(() => {
                tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('withTransition');
                tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('moveToRight');
                monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('withTransition');
                monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('moveToRight');
                setTimeout(() => {
                    tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('withTransition');
                    monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('withTransition');
                }, 100);
            }, 100);
        }, 100);
    }
    handlePrevMonth() {
        var _a, _b;
        const tbody = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('.tbody');
        const monthName = (_b = this.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('.header > div');
        tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('withTransition');
        tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('moveToRight');
        monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('withTransition');
        monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('moveToRight');
        const month = parse(this.month, 'MM', new Date());
        const monthMinusDate = subMonths(month, 1);
        const monthMinusString = format(monthMinusDate, 'MM', {
            locale: this.locale,
        });
        this.month = monthMinusString;
        if (this.month === '12') {
            const year = parse(this.year.toString(), 'yyyy', new Date());
            const yearMinusDate = subYears(year, 1);
            const yearMinusString = format(yearMinusDate, 'yyyy', {
                locale: this.locale,
            });
            this.year = parseInt(yearMinusString, 10);
        }
        this.dispatchEvent(new CustomEvent('prev-month'));
        setTimeout(() => {
            tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('withTransition');
            tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('moveToLeft');
            tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('moveToRight');
            monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('withTransition');
            monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('moveToLeft');
            monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('moveToRight');
            setTimeout(() => {
                tbody === null || tbody === void 0 ? void 0 : tbody.classList.add('withTransition');
                tbody === null || tbody === void 0 ? void 0 : tbody.classList.remove('moveToLeft');
                monthName === null || monthName === void 0 ? void 0 : monthName.classList.add('withTransition');
                monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('moveToLeft');
                setTimeout(() => {
                    monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('withTransition');
                    monthName === null || monthName === void 0 ? void 0 : monthName.classList.remove('withTransition');
                }, 100);
            }, 100);
        }, 100);
    }
    setYears(from, to) {
        const yearsList = [];
        for (let i = from; i <= to; i += 1) {
            yearsList.push(i);
        }
        this.yearsList = yearsList;
    }
}
RangeDatepickerCalendar.styles = css `
    :host {
      display: block;
      width: 266px;
    }

    :host > div {
      overflow: hidden;
    }

    div.table {
      display: table;
      border-collapse: collapse;
      table-layout: fixed;
    }

    div.th {
      display: table-cell;
      color: var(--range-datepicker-day-names-text, rgb(117, 117, 117));
      font-size: 11px;
      width: 38px;
      padding: 0;
      margin: 0;
      text-align: center;
    }

    div.tr {
      display: table-row;
      height: 38px;
    }

    div.td {
      display: table-cell;
      padding: 0;
      width: 38px;
      margin: 0;
      height: 38px;
    }

    .header {
      display: flex;
      flex-direction: row;
      align-items: center;
      width: 266px;
      margin: 10px 0;
      text-align: center;
      color: var(--range-datepicker-month-text);
    }

    .headerTitle {
      display: flex;
      flex: 1;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .header mwc-icon-button {
      padding: 0;
      --mdc-icon-size: 30px;
    }

    .header::first-letter {
      text-transform: uppercase;
    }

    .header > div > div {
      margin-right: 8px;
    }

    mwc-list {
      max-height: 200px;
    }

    div.tbody {
      transition: all 0ms;
      transform: translateX(0);
      height: 235px;
    }

    .withTransition {
      transition: all 100ms;
    }

    .moveToLeft {
      transform: translateX(-274px);
    }

    .moveToRight {
      transform: translateX(274px);
    }

    .withTransition td,
    .moveToLeft td,
    .moveToRight td {
      border: none;
    }

    .year-container {
      position: relative;
      display: flex;
      align-items: center;
    }

    .year-change {
      max-height: 200px;
    }
  `;
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "dateFrom", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "dateTo", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "hoveredDate", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCalendar.prototype, "enableYearChange", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "month", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCalendar.prototype, "narrow", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCalendar.prototype, "noRange", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCalendar.prototype, "next", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepickerCalendar.prototype, "prev", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "year", void 0);
__decorate([
    property({ type: Array })
], RangeDatepickerCalendar.prototype, "disabledDays", void 0);
__decorate([
    property({ type: Object })
], RangeDatepickerCalendar.prototype, "locale", null);
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "max", void 0);
__decorate([
    property({ type: String })
], RangeDatepickerCalendar.prototype, "min", void 0);
__decorate([
    property({ type: Array })
], RangeDatepickerCalendar.prototype, "yearsList", void 0);
__decorate([
    property({ type: Array })
], RangeDatepickerCalendar.prototype, "monthsList", void 0);
__decorate([
    property({ type: Array })
], RangeDatepickerCalendar.prototype, "dayNamesOfTheWeek", void 0);
__decorate([
    property({ type: Array })
], RangeDatepickerCalendar.prototype, "daysOfMonth", void 0);
AuroLibraryRuntimeUtils.prototype.registerComponent('wc-range-datepicker-calendar', RangeDatepickerCalendar);

var styleCss = css`@media screen and (max-width: 576px){:host{display:flex;justify-content:center}}.day{position:relative;width:var(--ds-size-500, 2.5rem);height:calc(var(--ds-size-700, 3.5rem) - 2px);padding:0;border-width:1px;border-style:solid;border-radius:var(--ds-size-300, 1.5rem);cursor:pointer;font-family:var(--ds-font-family-default, "AS Circular", Helvetica Neue, Arial, sans-serif);font-size:var(--ds-text-body-size-default, 1rem);user-select:none}.day.disabled{cursor:default !important}.day.inRange::before{position:absolute;z-index:-1;top:50%;left:50%;display:block;width:14.2857142857vw;height:var(--ds-size-600, 3rem);content:"";transform:translate(-50%, -50%)}@media screen and (min-width: 576px){.day.inRange::before{width:var(--ds-size-600, 3rem)}}.day.rangeDepartDate::before{position:absolute;z-index:-1;top:50%;left:50%;display:block;width:14.2857142857vw;height:var(--ds-size-600, 3rem);content:"";transform:translate(-50%, -50%);width:7.1428571429vw;transform:translate(0%, -50%)}@media screen and (min-width: 576px){.day.rangeDepartDate::before{width:calc(var(--ds-size-600, 3rem)/2)}}.day.rangeReturnDate::before,.day.lastHoveredDate::before{position:absolute;z-index:-1;top:50%;left:50%;display:block;width:14.2857142857vw;height:var(--ds-size-600, 3rem);content:"";transform:translate(-50%, -50%);width:7.1428571429vw;transform:translate(-100%, -50%)}@media screen and (min-width: 576px){.day.rangeReturnDate::before,.day.lastHoveredDate::before{width:calc(var(--ds-size-600, 3rem)/2)}}.dateSlot{display:flex;flex-direction:column;font-size:var(--ds-text-body-size-xxs, 0.625rem)}::slotted([slot^=date_]){position:absolute;top:80%;left:50%;width:80%;overflow:hidden;white-space:nowrap;transform:translate(-50%, -50%)}::slotted(auro-icon){max-height:24px;max-width:24px}:host([renderForDateSlot]) .buttonWrapper{position:relative;width:100%;top:5px}:host([renderForDateSlot]) .currentDayMarker{position:relative;padding-bottom:5px;top:-8px}@media screen and (min-width: 576px){.day{width:var(--ds-size-600, 3rem);height:var(--ds-size-800, 4rem);font-size:var(--ds-text-body-size-lg, 1.125rem)}.day:hover{cursor:pointer}.dateSlot{font-size:var(--ds-text-body-size-xs, 0.75rem)}}`;

var colorCss = css`:host ::slotted([slot^=date_]){color:var(--ds-auro-calendar-cell-price-text-color)}:host ::slotted([slot^=date_][highlight]){--ds-auro-calendar-cell-price-text-color: var(--ds-color-text-success-default, #0b6f4d)}.day{border-color:var(--ds-auro-calendar-cell-border-color);background-color:var(--ds-auro-calendar-cell-container-color);color:var(--ds-auro-calendar-cell-text-color)}.day.selected{--ds-auro-calendar-border-color: var(--ds-color-border-ui-active-default, #225296);--ds-auro-calendar-cell-container-color: var(--ds-color-container-ui-primary-active-default, #225296);--ds-auro-calendar-cell-text-color: var(--ds-color-text-primary-inverse, #ffffff);box-shadow:var(--ds-auro-calendar-boxshadow-color)}.day.selected:hover{--ds-auro-calendar-cell-container-color: var(--ds-color-container-primary-default, #ffffff);--ds-auro-calendar-cell-border-color: var(--ds-color-border-ui-focus-default, #2c67b5);box-shadow:unset}.day.selected:not(:hover){--ds-auro-calendar-cell-price-text-color: var(--ds-color-text-primary-inverse, #ffffff)}.day:hover{--ds-auro-calendar-cell-container-color: var(--ds-color-container-ui-secondary-hover-default, rgba(0, 0, 0, 0.03));--ds-auro-calendar-cell-text-color: var(--ds-color-text-primary-default, #2a2a2a)}.day.disabled{--ds-auro-calendar-cell-text-color: var(--ds-color-text-ui-disabled-default, #adadad);--ds-auro-calendar-cell-container-color: var(--ds-color-container-primary-default, #ffffff)}.day.inRange:before,.day.rangeDepartDate:before,.day.rangeReturnDate:before,.day.lastHoveredDate:before{background-color:var(--ds-auro-calendar-cell-in-range-color)}.day.sameDateTrip:before{--ds-auro-calendar-cell-in-range-color: transparent}:host([disabled]){--ds-auro-calendar-cell-price-text-color: var(--ds-color-text-ui-disabled-default, #adadad)}`;

var popoverVersion = '4.1.0';

/* eslint-disable max-lines, no-underscore-dangle, no-magic-numbers, no-underscore-dangle, max-params, no-void, init-declarations, no-extra-parens, arrow-parens, max-lines, line-comment-position, no-inline-comments, lit/binding-positions, lit/no-invalid-html */

class AuroCalendarCell extends LitElement {
  constructor() {
    super();

    this.day = null;
    this.selected = false;
    this.hovered = false;
    this.dateTo = null;
    this.dateFrom = null;
    this.month = null;
    this.min = null;
    this.max = null;
    this.disabled = false;
    this.disabledDays = [];
    this.hoveredDate = null;
    this.isCurrentDate = false;
    this._locale = null;
    this.dateStr = null;
    this.renderForDateSlot = false; // When false, the numerical date will render vertically centered. When true, the date will render off-center to the top and leave room below for the slot content.
    this.runtimeUtils = new AuroLibraryRuntimeUtils();

    /**
     * Generate unique names for dependency components.
     */
    const versioning = new AuroDependencyVersioning();
    this.popoverTag = versioning.generateTag('auro-popover', popoverVersion, AuroPopover);
  }

  // This function is to define props used within the scope of this component
  // Be sure to review  https://lit-element.polymer-project.org/guide/properties#reflected-attributes
  // to understand how to use reflected attributes with your property settings.
  static get properties() {
    return {
      // ...super.properties,
      day:           { type: Object },
      selected:      { type: Boolean },
      hovered:       { type: Boolean },
      dateTo:        { type: String },
      dateFrom:      { type: String },
      month:         { type: String },
      min:           { type: Number },
      max:           { type: Number },
      disabled:      { type: Boolean },
      disabledDays:  { type: Array },
      hoveredDate:   { type: String },
      isCurrentDate: { type: Boolean },
      locale:        { type: Object },
      dateStr:       { type: String },
      renderForDateSlot: { type: Boolean }
    };
  }

  get locale() {
    return this._locale ? this._locale : enUS;
  }

  set locale(value) {
    const oldValue = this._locale;
    this._locale = value;
    this.requestUpdate('locale', oldValue);
  }

  static get styles() {
    return [
      // ...super.styles,
      styleCss,
      colorCss,
      tokensCss
    ];
  }

  /**
   * Handles selected and hovered states of the calendar cell when the date changes.
   * @private
   * @param {Number} dateFrom - Depart date.
   * @param {Number} dateTo - Return date.
   * @param {Number} hoveredDate - Hovered date.
   * @param {Object} day - An object containing the dateFrom and day of month values.
   * @returns {void}
   */
  dateChanged(dateFrom, dateTo, hoveredDate, day) {
    this.selected = false;
    this.hovered = false;

    const parsedDateFrom = parseInt(dateFrom, 10);
    const parsedDateTo = parseInt(dateTo, 10);

    if (day) {
      const departTimestamp = startOfDay(parsedDateFrom * 1000) / 1000;
      const returnTimestamp = startOfDay(parsedDateTo * 1000) / 1000;

      if (day.date === departTimestamp || day.date === returnTimestamp) {
        this.selected = true;
      }

      if (((hoveredDate === day.date || day.date < hoveredDate) && day.date > parsedDateFrom && !parsedDateTo && !Number.isNaN(parsedDateFrom) && parsedDateFrom !== undefined && !this.selected) || (day.date > parsedDateFrom && day.date < parsedDateTo)) {
        this.hovered = true;
      }
    }
  }

  /**
   * Handles user click events and calls datepicker to update the value(s).
   * @private
   * @returns {void}
   */
  handleTap() {
    if (!this.disabled) {
      this.datepicker.handleCellClick(this.day.date);
    }
  }

  /**
   * Handles user hover events and dispatches a custom event.
   * @private
   * @returns {void}
   */
  handleHover() {
    this.hovered = true;

    let _a;
    this.dispatchEvent(new CustomEvent('date-is-hovered', {
      detail: { date: (_a = this.day) === null || _a === void 0 ? void 0 : _a.date },
    }));
  }

  /**
   * Checks if the current date is a valid date depending on the min and max values.
   * @private
   * @param {Object} day - An object containing the dateFrom and day of month values.
   * @param {Number} min - The minimum date value.
   * @param {Number} max - The maximum date value.
   * @param {Array} disabledDays - An array of disabled dates.
   * @returns {Boolean} - True if the date is disabled.
   */
  isEnabled(day, min, max, disabledDays) {
    this.removeAttribute('disabled');

    if (disabledDays && day && day.date) {
      if (day.date < min || day.date > max || disabledDays.findIndex(disabledDay => parseInt(disabledDay, 10) === day.date) !== -1) {
        this.setAttribute('disabled', true);
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if the current date is the depart date.
   * @private
   * @param {Object} day - An object containing the dateFrom and day of month values.
   * @param {Number} dateFrom - Depart date.
   * @returns {Boolean} True if the date is the depart date.
   */
  isDepartDate(day, dateFrom) {
    const parsedDateFrom = parseInt(dateFrom, 10);
    const departTimestamp = startOfDay(parsedDateFrom * 1000) / 1000;

    return this.selected && day.date === departTimestamp;
  }

  /**
   * Checks if the current date is the return date.
   * @private
   * @param {Object} day - An object containing the dateFrom and day of month values.
   * @param {Number} dateFrom - Depart date.
   * @param {Number} dateTo - Return date.
   * @returns {Boolean} True if the date is the return date.
   */
  isReturnDate(day, dateFrom, dateTo) {
    const parsedDateTo = parseInt(dateTo, 10);
    const returnTimestamp = startOfDay(parsedDateTo * 1000) / 1000;

    return this.selected && day.date === returnTimestamp && dateFrom;
  }

  /**
   * Checks if the current date is between dateFrom and dateTo.
   * @private
   * @param {Object} day - An object containing the dateFrom and day of month values.
   * @param {Number} dateFrom - Depart date.
   * @param {Number} dateTo - Return date.
   * @returns {Boolean} True if the current date is between dateFrom and dateTo.
   */
  isInRange(day, dateFrom, dateTo) {

    /**
     * Cell is in not range if any of the following are true:
     * - Datepicker does not support range selection.
     * - First date has not been selected.
     * - Cell date is before or equal first date.
     * - Both range dates selected and current cell is after the second date.
     */
    if (!this.datepicker.hasAttribute('range') || (!dateFrom || day.date <= dateFrom) || (dateTo && day.date >= dateTo)) {
      return false;
    }

    return true;
  }

  /**
   * Determines the hovered date appearing latest in the calendar.
   * @private
   * @param {Object} day - An object containing the dateFrom and day of month values.
   * @param {Number} dateFrom - Depart date.
   * @param {Number} dateTo - Return date.
   * @param {Number} hoveredDate - Hovered date.
   * @returns {Boolean} True if the hovered date is the latest hovered date in the calendar.
   */
  isLastHoveredDate(day, dateFrom, dateTo, hoveredDate) {
    return dateFrom && hoveredDate > dateFrom && day.date === hoveredDate && !dateTo;
  }

  /**
   * Determines the title of the auro-calendar-cell.
   * @private
   * @param {Number} date - The date of the auro-calendar-cell.
   * @returns {String} The title of the auro-calendar-cell in the user's locale.
   */
  getTitle(date) {
    if (date === undefined) {
      return '';
    }
    return format(date * 1000, 'PPPP', {
      locale: this.locale,
    });
  }

  /**
   * Gets the name of the date slot.
   * @private
   * @returns {void}
   */
  setDateSlotName() {
    const date = new Date(this.day.date * 1000);

    let month = date.getMonth() + 1;
    let day = date.getDate();

    if (month.toString().length === 1) {
      month = `0${month}`;
    }

    if (day.toString().length === 1) {
      day = `0${day}`;
    }

    const year = date.getFullYear();

    this.dateStr = `${month}_${day}_${year}`;
  }

  /**
   * Remove existing cell slot content and clone any current slot content from the root `auro-datepicker` which matches this cells date.
   * @private
   * @returns {void}
   */
  handleSlotContent() {
    try {
      // Get the slot names for this cell
      const dateSlotName = `date_${this.dateStr}`;
      const popoverSlotName = `popover_${this.dateStr}`;

      // Remove any existing slot content from this cell
      const existingSlotContent = this.querySelectorAll(`[slot]`);

      existingSlotContent.forEach((slot) => {
        slot.remove();
      });

      // // Get any slots for this cell from the datepicker
      const dateSlotContent = this.datepicker.querySelector(`[slot="${dateSlotName}"]`);
      const popoverSlotContent = this.datepicker.querySelector(`[slot="${popoverSlotName}"]`);

      // Insert any fetched slot content into this cell
      if (dateSlotContent) {
        this.appendChild(dateSlotContent.cloneNode(true));
        this.setAttribute('renderForDateSlot', true);
      } else {
        this.removeAttribute('renderForDateSlot');
      }

      if (popoverSlotContent) {
        this.appendChild(popoverSlotContent.cloneNode(true));
        this.auroPopover.removeAttribute('disabled');
      } else {
        this.auroPopover.setAttribute('disabled', true);
      }
    } catch (err) { // eslint-disable-line no-unused-vars
      // Error handling goes here
    }
  }

  firstUpdated() {
    this.datepicker = this.runtimeUtils.closestElement('auro-datepicker', this) ||
      this.runtimeUtils.closestElement('[auro-datepicker]', this);

    if (this.datepicker) {
      this.datepicker.addEventListener('auroDatePicker-newSlotContent', () => {
        this.handleSlotContent();
      });
    }

    this.calendarMonth = this.runtimeUtils.closestElement('auro-calendar-month', this);
    this.auroPopover = this.shadowRoot.querySelector(this.popoverTag._$litStatic$);

    this.auroPopover.boundary = this.calendarMonth;
  }

  updated(properties) {
    if (properties.has('dateFrom') || properties.has('dateTo') || properties.has('hoveredDate') || properties.has('day')) {
      this.dateChanged(this.dateFrom, this.dateTo, this.hoveredDate, this.day);
    }

    this.setDateSlotName();
    this.handleSlotContent();
  }

  render() {
    const buttonClasses = {
      'day': true,
      'currentDate': this.currentDate,
      'selected': this.selected,
      'inRange': this.hovered && this.isInRange(this.day, this.dateFrom, this.dateTo),
      'lastHoveredDate': this.isLastHoveredDate(this.day, this.dateFrom, this.dateTo, this.hoveredDate) && this.datepicker && this.datepicker.hasAttribute('range'),
      'disabled': this.isEnabled(this.day, this.min, this.max, this.disabledDays),
      'rangeDepartDate': this.isDepartDate(this.day, this.dateFrom) && (this.hoveredDate > this.dateFrom || this.dateTo),
      'rangeReturnDate': this.isReturnDate(this.day, this.dateFrom, this.dateTo),
      'sameDateTrip': this.dateFrom === this.dateTo
    };

    let _a, _b;
    return html$1`
      <${this.popoverTag}>
        <slot name="popover_${this.dateStr}"></slot>
        <button
          slot="trigger"
          @click="${this.handleTap}"
          @mouseover="${this.handleHover}"
          @focus="${this.handleHover}"
          class="${classMap(buttonClasses)}"
          ?disabled="${this.disabled}"
          title="${this.getTitle((_a = this.day) === null || _a === void 0 ? void 0 : _a.date)}"
          tabindex="-1">
          <div class="buttonWrapper">
            <div class="currentDayMarker">${(_b = this.day) === null || _b === void 0 ? void 0 : _b.title}</div>
            <div class="dateSlot" part="dateSlot">
              <slot name="date_${this.dateStr}"></slot>
            </div>
          </div>
        </button>
      </${this.popoverTag}>
    `;
  }
}

if (!customElements.get('auro-calendar-cell')) {
  customElements.define('auro-calendar-cell', AuroCalendarCell);
}

// See https://git.io/JJ6SJ for "How to document your components using JSDoc"

/* eslint-disable no-magic-numbers, dot-location */

class AuroCalendarMonth extends RangeDatepickerCalendar {
  static get styles() {
    return [
      // ...super.styles,
      styleCss$1,
      colorCss$1,
      tokensCss
    ];
  }

  async firstUpdated() {
    this.monthsList = [
      '01',
      '02',
      '03',
      '04',
      '05',
      '06',
      '07',
      '08',
      '09',
      '10',
      '11',
      '12',
    ];
    setTimeout(() => {
      this.setYears(1930, 2100);
    });

    await this.updateComplete;
  }

  /**
   * Determines the current month name based on locale.
   * This is a rewrite of the function used in the class RangeDatepickerCalendar and should not be removed from here.
   * @private
   * @returns {void}
   */
  localeChanged() {
    const dayNamesOfTheWeek = [];
    for (let int = 0; int < 7; int += 1) {
      dayNamesOfTheWeek.push(this.locale.localize.day(int, { width: 'narrow' }));
    }
    const firstDayOfWeek = this.locale.options.weekStartsOn
      ? this.locale.options.weekStartsOn
      : 0;
    const tmp = dayNamesOfTheWeek.slice().splice(0, firstDayOfWeek);
    const newDayNamesOfTheWeek = dayNamesOfTheWeek
      .slice()
      .splice(firstDayOfWeek, dayNamesOfTheWeek.length)
      .concat(tmp);
    this.dayNamesOfTheWeek = newDayNamesOfTheWeek;
  }

  renderDay(day) {
    return html`
      <div class="td ${this.tdIsEnabled(day)}">
        ${day
          ? html`
              <auro-calendar-cell
                .disabledDays="${this.disabledDays}"
                .min="${this.min}"
                .max="${this.max}"
                .month="${this.month}"
                .hoveredDate="${this.hoveredDate}"
                .dateTo="${this.dateTo}"
                .dateFrom="${this.dateFrom}"
                .locale="${this.locale}"
                .day="${day}"
                ?isCurrentDate="${this.isCurrentDate(day)}"
                @date-is-selected="${this.handleDateSelected}"
                @date-is-hovered="${this.handleDateHovered}"
              >
              </auro-calendar-cell>
          `
          : null}
      </div>
    `;
  }

  /* Disabling linter for render as this code is directly from range-datepicker-calendar */
  /* eslint-disable */
  render() {
    var _a, _b;
    
    return html `
      <div>
        <div class="header">
          ${this.renderPrevButton()}
          <div class="headerTitle">
            <div>${this.computeCurrentMonthName(this.month, this.year)}</div>
            <div>${this.renderYear()}</div>
          </div>
          ${this.renderNextButton()}
        </div>

        <div class="table">
          <div class="thead">
            <div class="tr">
              ${(_a = this.dayNamesOfTheWeek) === null || _a === void 0 ? void 0 : _a.map(dayNameOfWeek => this.renderDayOfWeek(dayNameOfWeek))}
            </div>
          </div>
          <div class="tbody">
            ${(_b = this.daysOfMonth) === null || _b === void 0 ? void 0 : _b.map(week => this.renderWeek(week))}
          </div>
        </div>
      </div>
    `;
  }
  /* eslint-enable */
}

if (!customElements.get('auro-calendar-month')) {
  customElements.define('auro-calendar-month', AuroCalendarMonth);
}

class RangeDatepicker extends LitElement {
    constructor() {
        super();
        /**
         * Array of disabled days. Format is Unix timestamp.
         */
        this.disabledDays = [];
        /**
         * Display a select year control.
         */
        this.enableYearChange = false;
        /**
         * Force display of only one month.
         */
        this.forceNarrow = false;
        /**
         * Set locale of the calendar.
         */
        this.locale = null;
        /**
         * Max date. Format is Unix timestamp
         */
        this.max = '8640000000000';
        /**
         * Minimal date. Format is Unix timestamp
         */
        this.min = '-8640000000000';
        /**
         * If true only one date can be selected.
         */
        this.noRange = false;
        this.dateFrom = null;
        this.dateTo = null;
        this.hoveredDate = null;
        this.monthPlus = null;
        this.yearPlus = null;
        this.narrow = false;
        const now = new Date();
        this.month = getMonth(now) + 1;
        this.year = getYear(now);
        this.monthChanged(this.month, this.year);
    }
    render() {
        return this.isNarrow(this.forceNarrow, this.narrow)
            ? this.renderNarrow()
            : this.renderNormal();
    }
    renderNormal() {
        return html `
      <div id="container">
        <wc-range-datepicker-calendar
          id="firstDatePicker"
          .disabledDays="${this.disabledDays}"
          min="${this.min}"
          max="${this.max}"
          ?enableYearChange="${this.enableYearChange}"
          ?prev="${true}"
          ?noRange="${this.noRange}"
          .hoveredDate="${this.hoveredDate}"
          .dateTo="${this.dateTo}"
          .dateFrom="${this.dateFrom}"
          .locale="${this.locale}"
          month="${this.month}"
          year="${this.year}"
          @prev-month="${this.handlePrevMonth}"
          @hovered-date-changed="${this.hoveredDateChanged}"
          @date-from-changed="${this.dateFromChanged}"
          @date-to-changed="${this.dateToChanged}"
        >
        </wc-range-datepicker-calendar>
        <wc-range-datepicker-calendar
          .disabledDays="${this.disabledDays}"
          min="${this.min}"
          max="${this.max}"
          ?enableYearChange="${this.enableYearChange}"
          ?next="${true}"
          ?noRange="${this.noRange}"
          .hoveredDate="${this.hoveredDate}"
          .dateTo="${this.dateTo}"
          .dateFrom="${this.dateFrom}"
          .locale="${this.locale}"
          month="${this.monthPlus}"
          year="${this.yearPlus}"
          @next-month="${this.handleNextMonth}"
          @hovered-date-changed="${this.hoveredDateChanged}"
          @date-from-changed="${this.dateFromChanged}"
          @date-to-changed="${this.dateToChanged}"
        >
        </wc-range-datepicker-calendar>
      </div>
    `;
    }
    renderNarrow() {
        return html `
      <wc-range-datepicker-calendar
        .disabledDays="${this.disabledDays}"
        min="${this.min}"
        max="${this.max}"
        ?enableYearChange="${this.enableYearChange}"
        ?noRange="${this.noRange}"
        ?narrow="${this.isNarrow(this.forceNarrow, this.narrow)}"
        .hoveredDate="${this.hoveredDate}"
        .dateTo="${this.dateTo}"
        .dateFrom="${this.dateFrom}"
        .locale="${this.locale}"
        ?prev="${true}"
        ?next="${true}"
        month="${this.monthPlus}"
        year="${this.yearPlus}"
        @hovered-date-changed="${this.hoveredDateChanged}"
        @date-from-changed="${this.dateFromChanged}"
        @date-to-changed="${this.dateToChanged}"
      >
      </wc-range-datepicker-calendar>
    `;
    }
    firstUpdated() {
        const mql = window.matchMedia('(max-width: 650px)');
        mql.addListener(mqlEvent => this.queryMatchesChanged(mqlEvent));
        this.queryMatchesChanged(mql);
    }
    updated(properties) {
        if (properties.has('month') || properties.has('year')) {
            this.monthChanged(this.month, this.year);
        }
        if (properties.has('noRange')) {
            this.noRangeChanged(this.noRange, properties.get('noRange'));
        }
        if (properties.has('narrow')) {
            this.dispatchEvent(new CustomEvent('narrow-changed', { detail: { value: this.narrow } }));
        }
        if (properties.has('locale')) {
            this.localeChanged();
        }
    }
    isNarrow(forceNarrow, narrow) {
        return forceNarrow || narrow;
    }
    queryMatchesChanged(mql) {
        this.narrow = mql.matches;
        this.requestUpdate();
    }
    handlePrevMonth() {
        var _a;
        if (!this.enableYearChange) {
            const calendar = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('wc-range-datepicker-calendar[next]');
            calendar === null || calendar === void 0 ? void 0 : calendar.handlePrevMonth();
        }
    }
    handleNextMonth() {
        var _a;
        if (!this.enableYearChange) {
            const calendar = (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('wc-range-datepicker-calendar[prev]');
            calendar === null || calendar === void 0 ? void 0 : calendar.handleNextMonth();
        }
    }
    hoveredDateChanged(e) {
        this.hoveredDate = e.detail.value;
    }
    monthChanged(month, year) {
        if (year && month) {
            this.monthPlus = (month % 12) + 1;
            if (this.monthPlus === 1) {
                this.yearPlus = year + 1;
            }
            else {
                this.yearPlus = year;
            }
        }
    }
    noRangeChanged(isNoRange, wasNoRange) {
        if (!wasNoRange && isNoRange) {
            this.dateTo = null;
            this.hoveredDate = null;
        }
    }
    localeChanged() {
        if (!this.month) {
            this.month = getMonth(new Date());
        }
        if (!this.year) {
            this.year = getYear(new Date());
        }
    }
    dateToChanged(e) {
        this.dateTo = e.detail.value;
        this.dispatchEvent(new CustomEvent('date-to-changed', { detail: { value: e.detail.value } }));
    }
    dateFromChanged(e) {
        this.dateFrom = e.detail.value;
        this.dispatchEvent(new CustomEvent('date-from-changed', {
            detail: { value: e.detail.value },
        }));
    }
}
RangeDatepicker.styles = css `
    :host {
      display: block;
      position: relative;
    }

    #container {
      display: flex;
      flex-direction: row;
    }

    #firstDatePicker {
      margin-right: 16px;
    }
  `;
__decorate([
    property({ type: Array })
], RangeDatepicker.prototype, "disabledDays", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepicker.prototype, "enableYearChange", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepicker.prototype, "forceNarrow", void 0);
__decorate([
    property({ type: Object })
], RangeDatepicker.prototype, "locale", void 0);
__decorate([
    property({ type: String })
], RangeDatepicker.prototype, "max", void 0);
__decorate([
    property({ type: String })
], RangeDatepicker.prototype, "min", void 0);
__decorate([
    property({ type: Number })
], RangeDatepicker.prototype, "month", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepicker.prototype, "noRange", void 0);
__decorate([
    property({ type: Number })
], RangeDatepicker.prototype, "year", void 0);
__decorate([
    property({ type: String })
], RangeDatepicker.prototype, "dateFrom", void 0);
__decorate([
    property({ type: String })
], RangeDatepicker.prototype, "dateTo", void 0);
__decorate([
    property({ type: String })
], RangeDatepicker.prototype, "hoveredDate", void 0);
__decorate([
    property({ type: Number })
], RangeDatepicker.prototype, "monthPlus", void 0);
__decorate([
    property({ type: Number })
], RangeDatepicker.prototype, "yearPlus", void 0);
__decorate([
    property({ type: Boolean })
], RangeDatepicker.prototype, "narrow", void 0);

class CalendarUtilities {
  constructor() {
    this.util = new AuroDatepickerUtilities();
  }


  /**
   * Scroll the calendar month list to a given valid date if in mobile view.
   * @param {Object} elem - The calendar element.
   * @param {String} date - The date to scroll into view.
   * @returns {void}
   */
  scrollMonthIntoView(elem, date) {
    const mobileLayout = window.innerWidth < elem.mobileBreakpoint;

    if (this.util.validDateStr(date) && mobileLayout) {
      const month = new Date(date).getMonth() + 1;
      const year = new Date(date).getFullYear();
      const selector = `#month-${month}-${year}`;
      const monthElem = elem.shadowRoot.querySelector(selector);

      monthElem.scrollIntoView();
    }
  }

  /**
   * Sends an event requesting the dropdown bib be closed.
   * @private
   * @returns {void}
   */
  requestDismiss() {
    this.dispatchEvent(new CustomEvent('auroCalendar-dismissRequest', {
      bubbles: true,
      cancelable: false,
      composed: true,
    }));
  }

  /**
   * Handles the visibility of the previous and next month buttons.
   * @private
   * @param {Object} elem - The auro-calendar element.
   * @returns {void}
   */
  assessNavigationButtonVisibility(elem) {

    /**
     * Hide/show the previous month button.
     */

    // 1. Compare the first rendered month to the earliest renderable month to determine if the previous month button should be hidden or shown
    if (!elem.hasAttribute('calendarStartDate') && !elem.hasAttribute('minDate')) {
      elem.showPrevMonthBtn = true;
    } else if (this.util.convertDateToFirstOfMonth(new Date(elem.centralDate)) <= elem.firstMonthRenderable) {
      elem.showPrevMonthBtn = false;
    } else {
      elem.showPrevMonthBtn = true;
    }

    /**
     * Hide/show the next month button.
     */

    // 1. Determine the last month that can possibly be rendered into the DOM.
    let lastRenderableMonth = undefined; // eslint-disable-line no-undef-init

    if (elem.hasAttribute('calendarEndDate')) {
      lastRenderableMonth = new Date(elem.getAttribute('calendarEndDate'));
    } else if (elem.hasAttribute('maxDate')) {
      lastRenderableMonth = new Date(elem.getAttribute('maxDate'));
    }

    if (lastRenderableMonth) {
      lastRenderableMonth = this.util.convertDateToFirstOfMonth(lastRenderableMonth);
    }

    // 2. Determine the last month currently rendered into the DOM.
    let lastRenderedMonth = new Date(elem.centralDate);

    if (!elem.noRange) {
      lastRenderedMonth = new Date(lastRenderedMonth.setMonth(lastRenderedMonth.getMonth() + 1));
    }

    lastRenderedMonth = this.util.convertDateToFirstOfMonth(lastRenderedMonth);

    // 3. Compare the two and choose to show or hide the next month button
    if (lastRenderedMonth >= lastRenderableMonth) {
      elem.showNextMonthBtn = false;
    } else {
      elem.showNextMonthBtn = true;
    }

    // Request an update to the component needed to actually show/hide the buttons in the DOM
    elem.requestUpdate();
  }

  /**
   * Handles the change of the centralDate property.
   * @param {Object} elem - The auro-calendar element.
   * @private
   * @returns {void}
   */
  centralDateChanged(elem) {
    this.assessNavigationButtonVisibility(elem);

    elem.dispatchEvent(new CustomEvent('auroCalendar-centralDateChanged', {
      detail: {
        bubbles: true,
        cancelable: false,
        composed: true,
        date: elem.centralDate
      }
    }));
  }

  /**
   * Updates the month and year when the user navigates to a different calendar month.
   * @param {Object} elem - The auro-calendar element.
   * @param {String} direction - The direction the user is navigating.
   * @returns {void}
   */
  handleMonthChange(elem, direction) {
    // Determine if the month number is going to be incremented or decremented
    let increment = 0;

    if (direction === 'next') {
      increment = 1;
    } else if (direction === 'prev') {
      increment = -1; // eslint-disable-line no-magic-numbers
    }

    // calculate the new central date
    const newCentralDate = new Date(elem.centralDate).setMonth(new Date(elem.centralDate).getMonth() + increment);

    // set the new central date to the first day of the month
    elem.centralDate = this.util.convertDateToFirstOfMonth(newCentralDate);
  }
}

// See https://git.io/JJ6SJ for "How to document your components using JSDoc"
/**
 * @prop {Object} firstDayOfWeek - Weekday that will be displayed in first column of month grid.
 * 0: sunday, 1: monday, 2: tuesday, 3: wednesday , 4: thursday, 5: friday, 6: saturday
 * Default is 0.
 * @prop {Date | null} focusedDate - The currently focused date (if any).
 * @prop {Date} maxDate - Maximum date. All dates after will be disabled.
 * @prop {Date} minDate - Minimum date. All dates before will be disabled.
 * @prop {Date | undefined} selectedDate - The selected date, usually synchronized with datepicker-input.
 * Not to be confused with the focused date (therefore not necessarily in active month view).
 * @prop {string} weekdayHeaderNotation - Weekday header notation, based on Intl DatetimeFormat:
 * - 'short' (e.g., Thu)
 * - 'narrow' (e.g., T).
 * Default is 'short'.
 * @event auroCalendar-dateSelected - Notifies that a date has been selected in the calendar.
 * @event auroCalendar-ready - Notifies that the component has finished initializing.
 * @event auroCalendar-monthChanged - Notifies that the visible calendar month(s) have changed.
 */

/* eslint-disable no-magic-numbers, no-undef-init, max-lines */

// class AuroCalendar extends LitElement {
class AuroCalendar extends RangeDatepicker {
  constructor() {
    super();

    /**
     * @private
     */
    this.runtimeUtils = new AuroLibraryRuntimeUtils();

    /**
     * @private
     */
    this.util = new AuroDatepickerUtilities();

    /**
     * @private
     */
    this.utilCal = new CalendarUtilities();

    /**
     * @private
     */
    this.utilCalRender = new UtilitiesCalendarRender();

    this.datepicker = this.runtimeUtils.closestElement('auro-datepicker', this);
    this.calendarStartDate = undefined;
    this.calendarEndDate = undefined;
    this.centralDate = undefined;
    this.showPrevMonthBtn = true;
    this.showNextMonthBtn = true;

    /**
     * @private
     */
    this.firstMonthRenderable = undefined;

    /**
     * @private
     */
    this.calendarRangeMonths = null;

    /**
     * @private
     */
    this.numCalendars = undefined;

    /**
     * @private
     */
    this.mobileBreakpoint = 660;
  }

  static get styles() {
    return [
      styleCss$2,
      colorCss$2,
      tokensCss
    ];
  }

  static get properties() {
    return {
      numCalendars: {
        type: Number
      },
      dateFrom: {
        type: String
      },
      dateTo: {
        type: String
      },
      maxDate: {
        type: String,
        reflect: true
      },
      minDate: {
        type: String,
        reflect: true
      },
      calendarStartMonth: {
        type: String,
        reflect: true
      },
      calendarEndMonth: {
        type: String,
        reflect: true
      },
      centralDate: {
        type: String,
        reflect: true
      },
    };
  }

  /**
   * Updates the month and year when the user navigates to the previous calendar month.
   * @private
   * @returns {void}
   */
  handlePrevMonth() {
    this.utilCal.handleMonthChange(this, 'prev');
  }

  /**
   * Updates the month and year when the user navigates to the next calendar month.
   * @private
   * @returns {void}
   */
  handleNextMonth() {
    this.utilCal.handleMonthChange(this, 'next');
  }

  /**
   * Renders all of the auro-calendar-months HTML.
   * @private
   * @returns {Object} Returns the auro-calendar-months HTML.
   */
  renderAllCalendars() {
    this.utilCalRender.setFirstRenderableMonthDate(this);

    const mobileLayout = window.innerWidth < this.mobileBreakpoint;
    let renderedHtml = undefined;

    // Determine which month to render first
    let dateMatches = undefined;

    if (!mobileLayout && this.centralDate) {
      // On Desktop start the calendar at the central date if it exists, then minDate and finally the current date.
      if (this.centralDate) {
        dateMatches = this.util.datesMatch(this.firstRenderedMonth, this.util.convertDateToFirstOfMonth(this.centralDate));

        if (!dateMatches) {
          this.firstRenderedMonth = this.util.convertDateToFirstOfMonth(this.centralDate);
        }
      } else if (this.minDate) {
        dateMatches = this.util.datesMatch(this.firstRenderedMonth, this.util.convertDateToFirstOfMonth(this.minDate));

        if (!dateMatches) {
          this.firstRenderedMonth = this.util.convertDateToFirstOfMonth(this.minDate);
        }
      } else {
        const now = new Date();

        dateMatches = this.util.datesMatch(this.firstRenderedMonth, this.util.convertDateToFirstOfMonth(now));

        if (!dateMatches) {
          this.firstRenderedMonth = this.util.convertDateToFirstOfMonth(now);
        }
      }
    } else {
      // On mobile start the calendar at the previously determined first renderable month.
      this.firstRenderedMonth = this.firstMonthRenderable;
    }

    // Add the first calendar to the HTML
    const firstMonth = this.firstRenderedMonth.getMonth() + 1;
    const firstYear = this.firstRenderedMonth.getFullYear();

    renderedHtml = html`${renderedHtml}${this.utilCalRender.renderCalendar(this, firstMonth, firstYear)}`;

    // Loop through the number of remaining calendars to render and add the HTML
    let newMonthDate = undefined;

    for (let cal = 0; cal < this.numCalendars - 1; cal += 1) {

      const date = newMonthDate || this.firstRenderedMonth;

      const oldMonth = date.getMonth() + 1;
      const oldYear = date.getFullYear();

      let newMonth = undefined;
      let newYear = undefined;

      if (oldMonth === 12) {
        newMonth = 1;
        newYear = oldYear + 1;
      } else {
        newMonth = oldMonth + 1;
        newYear = oldYear;
      }

      const newMonthDateStr = `${newMonth}/1/${newYear}`;
      newMonthDate = new Date(newMonthDateStr);

      renderedHtml = html`${renderedHtml}${this.utilCalRender.renderCalendar(this, newMonth, newYear)}`;
    }

    return renderedHtml;
  }

  /**
   * Request the calendar be scrolled to a given date.
   * @param {String} date - The date to scroll into view.
   * @returns {void}
   */
  scrollMonthIntoView(date) {
    this.utilCal.scrollMonthIntoView(this, date);
  }

  firstUpdated() {
    this.addEventListener('date-from-changed', () => {
      this.dispatchEvent(new CustomEvent('auroCalendar-dateSelected', {
        bubbles: true,
        cancelable: false,
        composed: true,
      }));
    });

    this.addEventListener('date-to-changed', () => {
      if (this.dateTo === null) {
        this.dateTo = undefined;
      }
      this.dispatchEvent(new CustomEvent('auroCalendar-dateSelected', {
        bubbles: true,
        cancelable: false,
        composed: true,
      }));
    });

    this.utilCalRender.determineNumCalendarsToRender(this);

    window.addEventListener('resize', () => {
      this.utilCalRender.determineNumCalendarsToRender(this);
    });
  }

  updated(changedProperties) {
    if (changedProperties.has('noRange')) {
      this.noRangeChanged(this.noRange, changedProperties.get('noRange'));
    }

    if (changedProperties.has('narrow')) {
      this.dispatchEvent(new CustomEvent('narrow-changedProperties', { detail: { value: this.narrow } }));
    }

    if (changedProperties.has('locale')) {
      this.localeChanged();
    }

    if (changedProperties.has('centralDate')) {
      this.utilCal.centralDateChanged(this);
    }
  }

  render() {
    return html`
      <div class="calendarWrapper">
        <div class="mobileHeader">
          <div class="headerDateFrom">
            <span class="mobileDateLabel"><slot name="mobileDateLabel"></slot></span>
            <slot name="mobileDateFromStr"></slot>
          </div>
          <div class="headerDateTo"><slot name="mobileDateToStr"></slot></div>
        </div>
        <div class="calendars">
          ${this.renderAllCalendars(this)}
        </div>
        <div class="mobileFooter">
          <div class="mobileFooterActions">
            <auro-button fluid @click="${this.utilCal.requestDismiss}">Done</auro-button>
          </div>
        </div>
        ${this.showPrevMonthBtn ? html`
          <button class="calendarNavBtn prevMonth" @click="${this.handlePrevMonth}">
            ${this.util.generateIconHtml(chevronLeft)}
          </button>
        ` : undefined}
        ${this.showNextMonthBtn ? html`
          <button class="calendarNavBtn nextMonth" @click="${this.handleNextMonth}">
            ${this.util.generateIconHtml(chevronRight)}
          </button>
        ` : undefined}
      </div>
    `;
  }
}

if (!customElements.get('auro-calendar')) {
  customElements.define('auro-calendar', AuroCalendar);
}

var dropdownVersion = '3.1.0';

var inputVersion = '4.0.0';

// Copyright (c) 2022 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


// See https://git.io/JJ6SJ for "How to document your components using JSDoc"
/**
 * @prop {String} value - Value selected for the date picker.
 * @prop {String} valueEnd - Value selected for the second date picker when using date range.
 * @attr {String} error - When defined, sets persistent validity to `customError` and sets `setCustomValidity` = attribute value.
 * @attr {String} validity - Specifies the `validityState` this element is in.
 * @attr {String} setCustomValidity - Sets a custom help text message to display for all validityStates.
 * @attr {String} setCustomValidityRangeUnderflow - Custom help text message to display when validity = `rangeUnderflow`.
 * @attr {String} setCustomValidityRangeOverflow - Custom help text message to display when validity = `rangeOverflow`.
 * @attr {String} setCustomValidityValueMissing - Help text message to display when validity = `valueMissing`.
 * @attr {String} calendarStartDate - The first date that may be displayed in the calendar.
 * @attr {String} calendarEndDate - The last date that may be displayed in the calendar
 * @attr {String} calendarFocusDate - The date that will first be visually rendered to the user in the calendar.
 * @attr {Boolean} disabled - If set, disables the datepicker.
 * @attr {Boolean} noValidate - If set, disables auto-validation on blur.
 * @attr {Boolean} required - Populates the `required` attribute on the input. Used for client-side validation.
 * @attr {Boolean} range - If set, turns on date range functionality in auro-calendar.
 * @attr {String} centralDate - The date that determines the currently visible month.
 * @attr {String} maxDate - Maximum date. All dates after will be disabled.
 * @attr {String} minDate - Minimum date. All dates before will be disabled.
 * @attr {Array} monthNames = Names of all 12 months to render in the calendar, used for localization of date string in mobile layout.
 * @slot helpText - Defines the content of the helpText.
 * @slot mobileDateLabel - Defines the content to display above selected dates in the mobile layout.
 * @slot toLabel - Defines the label content for the second input when the `range` attribute is used.
 * @slot fromLabel - Defines the label content for the first input.
 * @slot date_MM_DD_YYYY - Defines the content to display in the auro-calendar-cell for the specified date. The content text is colored using the success state token when the `highlight` attribute is applied to the slot.
 * @slot popover_MM_DD_YYYY - Defines the content to display in the auro-calendar-cell popover for the specified date.
 * @csspart dropdown - Use for customizing the style of the dropdown.
 * @csspart trigger - Use for customizing the style of the datepicker trigger.
 * @csspart input - Use for customizing the style of the datepicker inputs.
 * @csspart calendarWrapper - Use for customizing the style of the calendar container.
 * @csspart calendar - Use for customizing the style of the calendar.
 * @csspart helpTextSpan - Use for customizing the style of the datepicker help text span.
 * @csspart helpText - Use for customizing the style of the datepicker help text.
 * @event auroDatePicker-ready - Notifies that the component has finished initializing.
 * @event auroDatePicker-valueSet - Notifies that the component has a new value set.
 * @event auroDatePicker-toggled - Notifies that the calendar dropdown has been opened/closed.
 * @event auroDatePicker-monthChanged - Notifies that the visible calendar month(s) have changed.
 * @event auroFormElement-validated - Notifies that the component value(s) have been validated.
 * @event auroDatePicker-newSlotContent - Notifies that new slot content has been added to the datepicker.
 */

// build the component class
class AuroDatePicker extends LitElement {
  constructor() {
    super();

    /**
     * @private
     */
    this.util = new AuroDatepickerUtilities();

    /**
     * @private
     */
    this.calendarRenderUtil = new UtilitiesCalendarRender();

    // If `calendarStartDate` is set, use that as the central date. Otherwise, use the current date.
    if (this.getAttribute('calendarStartDate') && this.util.validDateStr(this.getAttribute('calendarStartDate'))) {
      this.calendarRenderUtil.updateCentralDate(this, this.getAttribute('calendarStartDate'));
    } else {
      this.calendarRenderUtil.updateCentralDate(this, new Date());
    }

    this.disabled = false;
    this.required = false;
    this.range = false;
    this.noValidate = false;
    this.validity = undefined;
    this.value = undefined;
    this.valueEnd = undefined;
    this.calendarStartDate = undefined;
    this.calendarEndDate = undefined;
    this.calendarFocusDate = this.value;
    this.monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December'
    ];

    /**
     * @private
     */
    this.type = "month-day-year";

    /**
     * @private
     */
    this.dateSlotContent = [];

    /**
     * @private
     */
    this.validation = new AuroFormValidation();

    /**
     * @private
     */
    this.runtimeUtils = new AuroLibraryRuntimeUtils();

    /**
     * @private
     */
    this.forceScrollOnNextMobileCalendarRender = false;

    /**
     * Generate unique names for dependency components.
     */
    const versioning = new AuroDependencyVersioning();
    this.dropdownTag = versioning.generateTag('auro-dropdown', dropdownVersion, AuroDropdown);
    this.inputTag = versioning.generateTag('auro-input', inputVersion, AuroInput);
  }

  // This function is to define props used within the scope of this component
  // Be sure to review  https://lit-element.polymer-project.org/guide/properties#reflected-attributes
  // to understand how to use reflected attributes with your property settings.
  static get properties() {
    return {
      // ...super.properties,
      error: {
        type: String,
        reflect: true
      },
      noValidate: {
        type: Boolean
      },
      setCustomValidity: {
        type: String,
        reflect: true
      },
      setCustomValidityRangeUnderflow: {
        type: String,
        reflect: true
      },
      setCustomValidityRangeOverflow: {
        type: String,
        reflect: true
      },
      setCustomValidityValueMissing: {
        type: String,
        reflect: true
      },
      validity: {
        type: String,
        reflect: true
      },
      range: {
        type: Boolean,
        reflect: true
      },
      disabled: {
        type: Boolean,
        reflect: true
      },
      required: {
        type: Boolean,
        reflect: true
      },
      type: {
        type: String,
        reflect: true
      },
      value: {
        type: String,
        reflect: true
      },
      valueEnd: {
        type: String,
        reflect: true
      },
      centralDate: {
        type: String
      },
      maxDate: {
        type: String,
        reflect: true
      },
      minDate: {
        type: String,
        reflect: true
      },
      monthNames: {
        type: Array
      },
      calendarStartDate: {
        type: String,
        reflect: true
      },
      calendarEndDate: {
        type: String,
        reflect: true
      },
      calendarFocusDate: {
        type: String,
        reflect: true
      },

      /**
       * @private
       */
      dropdownElementName: { type: String },

      /**
       * @private
       */
      dropdownTag: { type: Object },

      /**
       * @private
       */
      inputElementName: { type: String },

      /**
       * @private
       */
      inputTag: { type: Object }
    };
  }

  static get styles() {
    return [
      styleCss$3,
      colorCss$3,
      tokensCss
    ];
  }

  /**
   * This will register this element with the browser.
   * @param {string} [name="auro-datepicker"] - The name of element that you want to register to.
   *
   * @example
   * AuroDatePicker.register("custom-datepicker") // this will register this element to <custom-datepicker/>
   *
   */
  static register(name = "auro-datepicker") {
    AuroLibraryRuntimeUtils.prototype.registerComponent(name, AuroDatePicker);
  }

  /**
   * Force the calendar view to the focus date when it changes.
   * @private
   * @returns {void}
   */
  handleFocusDateChange() {
    if (this.calendarFocusDate) {
      this.calendarRenderUtil.updateCentralDate(this, this.calendarFocusDate);

      this.forceScrollOnNextMobileCalendarRender = true;
    }
  }

  /**
   * @private
   * @param {Number} length - Number of characters for the returned random string.
   * @returns {string}
   */
  generateRandomString(length) {
    return Math.random().toString(36).substring(2, length + 2);
  }

  /**
   * Focuses the datepicker trigger input.
   * @param {String} focusInput - Pass in `endDate` to focus on the return input. No parameter is needed to focus on the depart input.
   * @returns {void}
   */
  focus(focusInput) {
    this.range && focusInput === 'endDate' ? this.inputList[1].focus() : this.inputList[0].focus();
  }


  /**
   * Converts valid time number to format used by wc-date-range API.
   * @private
   * @param {Date} date - Date to be converted.
   * @returns {Number} Simplified number.
   */
  convertToWcValidTime(date) {
    return new Date(date).getTime() / 1000;
  }

  /**
   * Converts date object into a string.
   * @private
   * @param {String} time - Unix timestamp to be converted to a date object.
   * @returns {Date} Date formatted as a string.
   */
  convertWcTimeToDate(time) {
    return new Date(time * 1000).toLocaleDateString('en-US', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    });
  }

  /**
   * Sends event notifying that the input has changed it's value.
   * @private
   * @returns {void}
   */
  notifyValueChanged() {
    let inputEvent = null;

    inputEvent = new Event('auroDatePicker-valueSet', {
      bubbles: true,
      composed: true,
    });

    // Dispatched event to alert outside shadow DOM context of event firing.
    this.dispatchEvent(inputEvent);
  }

  /**
   * Generates a date string used in the mobile calendar layout.
   * @private
   * @param {string} date - Date to parse into longer mobile version.
   * @returns {string}
   */
  getMobileDateStr(date) {
    let dateStr = '';
    const dateObj = new Date(date);

    if (date && this.util.validDateStr(date)) {
      dateStr += this.monthNames[dateObj.getMonth()].substring(0, 3);
      dateStr += ' ';
      dateStr += dateObj.getDate();
      dateStr += ', ';
      dateStr += dateObj.getFullYear();
      dateStr += ' (';
      // Need TODO: need to  make locale not be hardcoded - https://phrase.com/blog/posts/detecting-a-users-locale/
      dateStr += dateObj.toLocaleDateString('en-US', { weekday: 'short' });
      dateStr += ')';
    }

    return dateStr;
  }

  /**
   * Return appropriate error message.
   * @param {Object} evt - Event passed in from auro-input when the event triggered this function.
   * @private
   */
  getErrorMessage(evt) {
    if (evt) {
      const inputClass = evt.target.getAttribute('class');
      if (inputClass === 'dateFrom') {
        if (this.inputList[0].validity && this.inputList[0].validity !== 'valid') {
          this.errorMessage = evt.target.errorMessage;
        } else {
          this.errorMessage = undefined;
        }
      }

      if (inputClass === 'dateTo') {
        if (!this.errorMessage && this.inputList[1].validity && this.inputList[1].validity !== 'valid') {
          this.errorMessage = evt.target.errorMessage;
        }
      }
    }
  }

  /**
   * Changes the calendar's visibility to reflect the value of the central date attribute.
   * @private
   * @returns {void}
   */
  handleCentralDateChange() {
    this.calendar.setAttribute('centralDate', this.centralDate);
  }

  /**
   * Sends event notifying that the calendar popover has been opened.
   * @private
   * @returns {void}
   */
  notifyDatepickerToggled() {
    this.dispatchEvent(new CustomEvent('auroDatePicker-toggled', {
      bubbles: true,
      composed: true,
      detail: {
        expanded: this.dropdown.isPopoverVisible,
      },
    }));
  }

  /**
   * Sends event notifying that the calendar's visible month has changed.
   * @param {Object} event - Event passed in from auro-calendar when the event triggered this function.
   * @private
   * @returns {void}
   */
  notifyMonthChanged(event) {
    this.dispatchEvent(new CustomEvent('auroDatePicker-monthChanged', {
      bubbles: true,
      composed: true,
      detail: {
        month: event.detail.month,
        year: event.detail.year,
        numCalendars: event.detail.numCalendars,
      },
    }));
  }

  /**
   * Binds all behavior needed to the dropdown after rendering.
   * @private
   * @returns {void}
   */
  configureDropdown() {
    this.dropdown = this.shadowRoot.querySelector(this.dropdownTag._$litStatic$);

    this.dropdown.addEventListener('auroDropdown-triggerClick', () => {
      if (!this.isPopoverVisible) {
        this.dropdown.show();
      }
    });

    this.dropdown.addEventListener('auroDropdown-toggled', () => {
      this.setAttribute('aria-expanded', this.dropdown.isPopoverVisible);
      this.notifyDatepickerToggled();

      if (this.dropdown.getAttribute('data-show')) {
        if (this.forceScrollOnNextMobileCalendarRender) {
          this.calendar.scrollMonthIntoView(this.calendarFocusDate);
          this.forceScrollOnNextMobileCalendarRender = false;
        }
      }
    });

    if (!this.dropdown.hasAttribute('aria-expanded')) {
      this.dropdown.setAttribute('aria-expanded', this.dropdown.isPopoverVisible);
    }
  }

  /**
   * Binds all behavior needed to the input after rendering.
   * @private
   * @returns {void}
   */
  configureInput() {
    this.triggerInput = this.dropdown.querySelector('[slot="trigger"');

    this.inputList = [...this.dropdown.querySelectorAll(this.inputTag._$litStatic$)];

    this.handleReadOnly();

    this.inputList.forEach((input, index) => {
      // auto-show bib when manually editing the input value
      input.addEventListener('keyup', (evt) => {
        if (evt.key.length === 1 || evt.key === 'Delete' || evt.key === 'Backspace') {
          this.dropdown.show();
        }
      });

      input.addEventListener('input', () => {
        if (index === 0) {
          this.value = input.value;
        } else if (index === 1) {
          this.valueEnd = input.value;
        }

        this.notifyValueChanged();
      });

      input.addEventListener('auroFormElement-validated', (evt) => {
        if (evt.detail.validity === 'customError') {
          this.validity = evt.detail.validity;
          this.setCustomValidity = evt.detail.message;
        } else if (evt.target === this.inputList[0]) {
          this.validity = evt.detail.validity;
          this.setCustomValidity = evt.detail.message;
        } else if (this.inputList.length > 1 && evt.target === this.inputList[1] && (this.inputList[0].validity === 'valid' || this.inputList[0].validity === undefined)) {
          this.validity = evt.detail.validity;
          this.setCustomValidity = evt.detail.message;
        }
      });
    });
  }

  /**
   * Binds all behavior needed to the dropdown after rendering.
   * @private
   * @returns {void}
   */
  configureCalendar() {
    this.calendar = this.shadowRoot.querySelector('auro-calendar');

    this.calendar.addEventListener('auroCalendar-dateSelected', () => {
      if (this.inputList[0].value !== this.calendar.dateFrom && this.calendar.dateFrom !== undefined) {
        this.inputList[0].value = this.convertWcTimeToDate(this.calendar.dateFrom);
      }

      if (this.inputList[1] && this.calendar.dateTo && this.inputList[1].value !== this.calendar.dateTo) {
        this.inputList[1].value = this.convertWcTimeToDate(this.calendar.dateTo);
      }
    });

    this.calendar.addEventListener('auroCalendar-dismissRequest', () => {
      this.dropdown.hide();
    });

    this.calendar.addEventListener('auroCalendar-centralDateChanged', (event) => {
      this.notifyMonthChanged(event);
    });
  }

  /**
   * Binds all behavior needed to the datepicker after rendering.
   * @private
   * @returns {void}
   */
  configureDatepicker() {
    this.addEventListener('focusin', () => {

      /**
       * The datepicker is considered to be in it's initial state based on
       * if this.value === undefined. The first time we interact with the
       * datepicker manually, by applying focusin, we need to flag the
       * datepicker as no longer in the initial state.
       */
      if (this.value === undefined) {
        this.value = '';
      }

      if (this.valueEnd === undefined) {
        this.valueEnd = '';
      }
    });

    this.addEventListener('focusout', (evt) => {
      this.setAttribute('aria-expanded', this.dropdown.isPopoverVisible);

      if (!this.noValidate && !evt.detail.expanded && this.inputList[0].value !== undefined) {
        if (!this.contains(document.activeElement)) {
          this.validation.validate(this.inputList[0]);

          if (this.inputList[1] && this.inputList[1].value !== undefined) {
            this.validation.validate(this.inputList[1]);
          }
        }
      }
    });

    // Close the datepicker when clicking outside it
    document.addEventListener('click', (evt) => {
      if (!evt.composedPath().includes(this) && this.dropdown.isPopoverVisible) {
        this.dropdown.hide();
      }
    });

    document.activeElement.addEventListener('focusin', () => {
      if (document.activeElement !== document.querySelector('body') && !this.contains(document.activeElement)) {
        this.dropdown.hide();
      }
    });

    if (this.hasAttribute('value') && this.getAttribute('value').length > 0) {
      this.calendar.dateFrom = new Date(this.value).getTime();
    }

    if (this.hasAttribute('valueEnd') && this.getAttribute('valueEnd').length > 0) {
      this.calendar.dateTo = new Date(this.valueEnd).getTime();
    }
  }

  /**
   * Marks the component as ready and sends event.
   * @private
   * @returns {void}
   */
  notifyReady() {
    this.ready = true;

    this.dispatchEvent(new CustomEvent('auroDatePicker-ready', {
      bubbles: true,
      cancelable: false,
      composed: true,
    }));
  }

  /**
   * Sets the readonly attribute on the inputs based on the window width.
   * @private
   * @returns {void}
   */
  handleReadOnly() {
    // --ds-grid-breakpoint-sm
    const mobileBreakpoint = 576;

    this.inputList.forEach((input) => {
      if (window.innerWidth < mobileBreakpoint) {
        input.setAttribute('readonly', true);
      } else {
        input.removeAttribute('readonly');
      }
    });
  }

  /**
   * Keep the datepicker in sync with the calendar's central date.
   * @private
   * @param {Number} event - Event received from calendar with the new central date.
   * @returns {void}
   */
  handleCalendarCentralDateChange(event) {
    const match = this.util.datesMatch(event.detail.date, this.centralDate);

    if (!match) {
      this.calendarRenderUtil.updateCentralDate(this, event.detail.date);
    }
  }

  /**
   * Sets the datepicker's values to the auro-calendar-cell that was clicked.
   * @private
   * @param {Number} time - Unix timestamp to be converted to a date.
   * @returns {void}
   */
  handleCellClick(time) {
    this.cellClickActive = true;

    const newDate = this.convertWcTimeToDate(time);

    if (this.util.validDateStr(newDate)) {
      if (this.inputList.length > 1) {
        if (!this.value || !this.util.validDateStr(this.value)) {
          this.value = newDate;
        } else if (!this.valueEnd || !this.util.validDateStr(this.valueEnd)) {

          // verify the date is after this.value to insure we are setting a proper range
          if (new Date(newDate) >= new Date(this.value)) {
            this.valueEnd = newDate;
          }
        } else {
          this.value = newDate;
          this.valueEnd = '';
        }
      } else {
        this.value = newDate;
      }
    }
  }

  /**
   * Emits an event to notify the calendar cells to fetch their slot content.
   * @returns {void}
   */
  pushSlotContent() {
    this.dispatchEvent(new CustomEvent('auroDatePicker-newSlotContent'));
  }

  updated(changedProperties) {
    if (changedProperties.has('calendarFocusDate')) {
      this.handleFocusDateChange();
    }

    if (changedProperties.has('calendarStartDate')) {
      this.calendar.setAttribute('calendarStartDate', this.getAttribute('calendarStartDate'));
    }

    if (changedProperties.has('calendarEndDate')) {
      this.calendar.setAttribute('calendarEndDate', this.getAttribute('calendarEndDate'));
    }

    if (changedProperties.has('minDate')) {
      // If the minDate was set to a valid date
      if (this.util.validDateStr(this.minDate)) {
        // When there is no focusDate and no value, set the focusDate to the minDate
        const nothingSet = !this.calendarFocusDate && !this.value;
        const earlierThanMinDate = new Date(this.calendarFocusDate) < new Date(this.minDate);

        if (nothingSet || earlierThanMinDate) {
          this.calendarFocusDate = this.minDate;
        }
      }
    }

    if (changedProperties.has('value')) {
      // Change the calendar focus to the first valid date value only the first time the value is set
      if (!this.calendarFocusDate && this.util.validDateStr(this.value)) {
        this.calendarFocusDate = this.value;
      }

      if (this.cellClickActive) {
        this.cellClickActive = false;
      }

      if (this.value && this.util.validDateStr(this.value)) {
        if (this.calendar.dateFrom !== this.value) {
          this.calendar.dateFrom = this.convertToWcValidTime(this.value);
        }
      } else {
        if (this.inputList[0].value !== this.value) {
          if (this.value) {
            this.inputList[0].value = this.value;
          } else {
            this.inputList[0].value = '';
          }
        }

        if (this.calendar.dateFrom !== undefined) {
          this.calendar.dateFrom = undefined;
        }
      }

      // update the inputs
      if (this.inputList[0].value !== this.value) {
        if (this.value) {
          this.inputList[0].value = this.value;
        } else {
          this.inputList[0].value = '';
        }
      }

      this.validation.validate(this);
    }

    if (changedProperties.has('valueEnd') && this.inputList[1]) {
      // update the calendar
      if (this.valueEnd && this.util.validDateStr(this.valueEnd)) {
        this.calendar.dateTo = this.convertToWcValidTime(this.valueEnd);
      } else {
        if (this.inputList[1].value !== this.valueEnd) {
          if (this.valueEnd) {
            this.inputList[1].value = this.valueEnd;
          } else {
            this.inputList[1].value = '';
          }
        }

        if (this.calendar.dateTo !== undefined) {
          this.calendar.dateTo = undefined;
        }
      }

      // update the inputs
      if (this.inputList[1].value !== this.valueEnd) {
        if (this.valueEnd) {
          this.inputList[1].value = this.valueEnd;
        } else {
          this.inputList[1].value = '';
        }
      }

      this.validation.validate(this);
    }

    if (changedProperties.has('error')) {
      // Error attribute is passed down to the last input in the list to control the error state
      // This is done to prevent error icon from displaying on both inputs in range support
      const lastInput = this.inputList[this.inputList.length - 1];

      if (this.error) {
        // Set the error attribute on the last input
        lastInput.setAttribute('error', this.getAttribute('error'));
      } else {
        // Remove the error attribute on the last input
        lastInput.removeAttribute('error');
      }

      // Validate the last input
      this.validation.validate(lastInput, true);
    }

    if (this.value && this.valueEnd && this.util.validDateStr(this.value) && this.util.validDateStr(this.valueEnd)) {
      if (new Date(this.value) > new Date(this.valueEnd)) {
        this.valueEnd = undefined;
      }
    }

    // This resets the datepicker when the minDate is set to a new value that is
    // a later date than the current value date
    if (changedProperties.has('minDate')) {
      if (this.minDate) {
        const minDateMonth = Number(this.minDate.charAt(1));

        // This sets the visible month of the calendar to the minDate when the minDate is later
        // than the current visible date
        if (minDateMonth > this.calendar.month) {
          this.calendarRenderUtil.updateCentralDate(this, this.minDate);
        }

        if (this.value) {
          if (new Date(this.minDate).getTime() > new Date(this.value).getTime()) {
            this.value = undefined;

            if (this.range && this.valueEnd) {
              this.valueEnd = undefined;
            }

            this.calendarRenderUtil.updateCentralDate(this, this.minDate);
          }
        }
      }
    }

    // This resets the datepicker when the maxDate is set to a new value that is
    // an earlier date than the current value date
    if (changedProperties.has('maxDate')) {
      if (this.maxDate) {
        if (this.value) {
          if (new Date(this.maxDate).getTime() < new Date(this.value).getTime()) {
            this.value = undefined;

            if (this.range && this.valueEnd) {
              this.valueEnd = undefined;
            }

            this.calendarRenderUtil.updateCentralDate(this, this.maxDate);
          }
        }
      }
    }

    if (changedProperties.has('centralDate')) {
      this.handleCentralDateChange();
    }
  }

  firstUpdated() {
    // Add the tag name as an attribute if it is different than the component name
    this.runtimeUtils.handleComponentTagRename(this, 'auro-datepicker');

    this.configureDropdown();
    this.configureInput();
    this.configureCalendar();
    this.configureDatepicker();
    this.notifyReady();

    window.addEventListener('resize', () => {
      this.handleReadOnly();
    });
  }

  // function that renders the HTML and CSS into  the scope of the component
  render() {
    return html$1`
      <div class="outerWrapper">
        <${this.dropdownTag}
          for="dropdownMenu"
          bordered
          rounded
          ?disabled="${this.disabled}"
          ?error="${this.validity !== undefined && this.validity !== 'valid'}"
          disableEventShow
          noHideOnThisFocusLoss
          part="dropdown">
          <div slot="trigger" class="dpTriggerContent" part="trigger">
            <${this.inputTag}
              id="${this.generateRandomString(12)}"
              bordered
              class="dateFrom"
              ?required="${this.required}"
              noValidate
              .max="${this.maxDate}"
              .min="${this.minDate}"
              setCustomValidityValueMissing="${this.setCustomValidityValueMissing}"
              setCustomValidityRangeOverflow="${this.setCustomValidityRangeOverflow}"
              setCustomValidityRangeUnderflow="${this.setCustomValidityRangeUnderflow}"
              ?disabled="${this.disabled}"
              .type="${this.type}"
              part="input">
              <span slot="label"><slot name="fromLabel"></slot></span>
            </${this.inputTag}>
            ${this.range ? html$1`
              <${this.inputTag}
                id="${this.generateRandomString(12)}"
                bordered
                class="dateTo"
                ?required="${this.required}"
                noValidate
                .max="${this.maxDate}"
                .min="${this.minDate}"
                setCustomValidityValueMissing="${this.setCustomValidityValueMissing}"
                setCustomValidityRangeOverflow="${this.setCustomValidityRangeOverflow}"
                setCustomValidityRangeUnderflow="${this.setCustomValidityRangeUnderflow}"
                ?disabled="${this.disabled}"
                .type="${this.type}"
                part="input">
                <span slot="label"><slot name="toLabel"></slot></span>
              </${this.inputTag}>
            ` : undefined}
          </div>
          <div class="calendarWrapper" part="calendarWrapper">
            <auro-calendar
              ?noRange="${!this.range}"
              .min="${this.convertToWcValidTime(new Date(this.minDate))}"
              .max="${this.convertToWcValidTime(new Date(this.maxDate))}"
              .maxDate="${this.maxDate}"
              .minDate="${this.minDate}"
              part="calendar"
              @auroCalendar-centralDateChanged="${this.handleCalendarCentralDateChange}"
            >
              <slot slot="mobileDateLabel" name="mobileDateLabel"></slot>
              <span slot="mobileDateFromStr">${this.value ? this.getMobileDateStr(this.value) : html$1`<span class="placeholderDate">MM/DD/YYYY</span>`}</span>
              ${this.range ? html$1`<span slot="mobileDateToStr">${this.valueEnd ? this.getMobileDateStr(this.valueEnd) : html$1`<span class="placeholderDate">MM/DD/YYYY</span>`}</span>` : undefined}
            </auro-calendar>
          </div>
          <span slot="helpText" part="helpTextSpan">
            <!-- Help text and error message template -->
            ${!this.validity || this.validity === undefined || this.validity === 'valid'
              ? html$1`
                <slot name="helpText"></slot>
              ` : html$1`
                <p class="datepickerElement-helpText" id="${this.uniqueId}" role="alert" aria-live="assertive" part="helpText">
                  ${this.setCustomValidity}
                </p>`
            }
          </span>
        </${this.dropdownTag}>
      </div>
    `;
  }
}

AuroDatePicker.register(); // registering to auro-datepicker
AuroDatePicker.register('custom-datepicker');

function initExamples(initCount) {
}

export { initExamples };
